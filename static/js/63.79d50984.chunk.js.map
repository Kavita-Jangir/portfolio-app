{"version":3,"sources":["D:/react_app/app_1/node_modules/@codemirror/legacy-modes/mode/mumps.js"],"names":["wordRegexp","words","RegExp","join","__webpack_require__","r","__webpack_exports__","d","mumps","singleOperators","doubleOperators","singleDelimiters","brackets","identifiers","intrinsicFuncs","command","name","startState","label","commandMode","token","stream","state","style","sol","ch","peek","skipToEnd","match","skipTo","next","test","eatWhile","tokenBase"],"mappings":"2FAAA,SAAAA,EAAAC,GACA,WAAAC,OAAA,MAAAD,EAAAE,KAAA,oBADAC,EAAAC,EAAAC,GAAAF,EAAAG,EAAAD,EAAA,0BAAAE,IAGA,IAAAC,EAAA,IAAAP,OAAA,sCACAQ,EAAA,IAAAR,OAAA,8CACAS,EAAA,IAAAT,OAAA,YACAU,EAAA,IAAAV,OAAA,QACAW,EAAA,IAAAX,OAAA,0BAIAY,EAAAd,EADA,mlBAEAe,EAAAf,EAJA,6RAoFO,IAAAQ,EAAA,CACPQ,KAAA,QACAC,WAAA,WACA,OACAC,OAAA,EACAC,YAAA,IAGAC,MAAA,SAAAC,EAAAC,GACA,IAAAC,EAxFA,SAAAF,EAAAC,GACAD,EAAAG,QACAF,EAAAJ,OAAA,EACAI,EAAAH,YAAA,GASA,IAAAM,EAAAJ,EAAAK,OAcA,MAbA,KAAAD,GAAA,MAAAA,GAEAH,EAAAJ,OAAA,EACA,GAAAI,EAAAH,YAAAG,EAAAH,YAAA,GAAsDG,EAAAH,YAAA,MAAAG,EAAAH,eAAAG,EAAAH,YAAA,IACnD,KAAAM,GAAAH,EAAAH,YAAA,IACHG,EAAAH,YAAA,KAAAM,GAAA,EACA,GAIA,MAAAA,GAAA,OAAAA,IAAAH,EAAAJ,OAAA,GAGA,MAAAO,GACAJ,EAAAM,YACA,WAIAN,EAAAO,MAAA,6CAGA,KAAAH,EACAJ,EAAAQ,OAAA,MACAR,EAAAS,OACA,WAEAT,EAAAM,YACA,SAKAN,EAAAO,MAAAlB,IAAAW,EAAAO,MAAAnB,GAAA,WAGAY,EAAAO,MAAAjB,GAAA,KACAC,EAAAmB,KAAAN,IACAJ,EAAAS,OACA,WAEAR,EAAAH,YAAA,GAAAE,EAAAO,MAAAb,GAAA,iBACAM,EAAAO,MAAAd,GAAA,UACAO,EAAAO,MAAAf,GAAA,WAIA,MAAAY,GAAA,MAAAA,GACAJ,EAAAS,OACA,WAIA,MAAAL,GACAJ,EAAAS,OACA,kBAEA,QAAAC,KAAAN,IACAJ,EAAAW,SAAA,SACA,aAIAX,EAAAS,OACA,SAWAG,CAAAZ,EAAAC,GACA,OAAAA,EAAAJ,MAAA,MACAK","file":"static/js/63.79d50984.chunk.js","sourcesContent":["function wordRegexp(words) {\n  return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\", \"i\");\n}\nvar singleOperators = new RegExp(\"^[\\\\+\\\\-\\\\*/&#!_?\\\\\\\\<>=\\\\'\\\\[\\\\]]\");\nvar doubleOperators = new RegExp(\"^(('=)|(<=)|(>=)|('>)|('<)|([[)|(]])|(^$))\");\nvar singleDelimiters = new RegExp(\"^[\\\\.,:]\");\nvar brackets = new RegExp(\"[()]\");\nvar identifiers = new RegExp(\"^[%A-Za-z][A-Za-z0-9]*\");\nvar commandKeywords = [\"break\", \"close\", \"do\", \"else\", \"for\", \"goto\", \"halt\", \"hang\", \"if\", \"job\", \"kill\", \"lock\", \"merge\", \"new\", \"open\", \"quit\", \"read\", \"set\", \"tcommit\", \"trollback\", \"tstart\", \"use\", \"view\", \"write\", \"xecute\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"q\", \"r\", \"s\", \"tc\", \"tro\", \"ts\", \"u\", \"v\", \"w\", \"x\"];\n// The following list includes intrinsic functions _and_ special variables\nvar intrinsicFuncsWords = [\"\\\\$ascii\", \"\\\\$char\", \"\\\\$data\", \"\\\\$ecode\", \"\\\\$estack\", \"\\\\$etrap\", \"\\\\$extract\", \"\\\\$find\", \"\\\\$fnumber\", \"\\\\$get\", \"\\\\$horolog\", \"\\\\$io\", \"\\\\$increment\", \"\\\\$job\", \"\\\\$justify\", \"\\\\$length\", \"\\\\$name\", \"\\\\$next\", \"\\\\$order\", \"\\\\$piece\", \"\\\\$qlength\", \"\\\\$qsubscript\", \"\\\\$query\", \"\\\\$quit\", \"\\\\$random\", \"\\\\$reverse\", \"\\\\$select\", \"\\\\$stack\", \"\\\\$test\", \"\\\\$text\", \"\\\\$translate\", \"\\\\$view\", \"\\\\$x\", \"\\\\$y\", \"\\\\$a\", \"\\\\$c\", \"\\\\$d\", \"\\\\$e\", \"\\\\$ec\", \"\\\\$es\", \"\\\\$et\", \"\\\\$f\", \"\\\\$fn\", \"\\\\$g\", \"\\\\$h\", \"\\\\$i\", \"\\\\$j\", \"\\\\$l\", \"\\\\$n\", \"\\\\$na\", \"\\\\$o\", \"\\\\$p\", \"\\\\$q\", \"\\\\$ql\", \"\\\\$qs\", \"\\\\$r\", \"\\\\$re\", \"\\\\$s\", \"\\\\$st\", \"\\\\$t\", \"\\\\$tr\", \"\\\\$v\", \"\\\\$z\"];\nvar intrinsicFuncs = wordRegexp(intrinsicFuncsWords);\nvar command = wordRegexp(commandKeywords);\nfunction tokenBase(stream, state) {\n  if (stream.sol()) {\n    state.label = true;\n    state.commandMode = 0;\n  }\n\n  // The <space> character has meaning in MUMPS. Ignoring consecutive\n  // spaces would interfere with interpreting whether the next non-space\n  // character belongs to the command or argument context.\n\n  // Examine each character and update a mode variable whose interpretation is:\n  //   >0 => command    0 => argument    <0 => command post-conditional\n  var ch = stream.peek();\n  if (ch == \" \" || ch == \"\\t\") {\n    // Pre-process <space>\n    state.label = false;\n    if (state.commandMode == 0) state.commandMode = 1;else if (state.commandMode < 0 || state.commandMode == 2) state.commandMode = 0;\n  } else if (ch != \".\" && state.commandMode > 0) {\n    if (ch == \":\") state.commandMode = -1; // SIS - Command post-conditional\n    else state.commandMode = 2;\n  }\n\n  // Do not color parameter list as line tag\n  if (ch === \"(\" || ch === \"\\t\") state.label = false;\n\n  // MUMPS comment starts with \";\"\n  if (ch === \";\") {\n    stream.skipToEnd();\n    return \"comment\";\n  }\n\n  // Number Literals // SIS/RLM - MUMPS permits canonic number followed by concatenate operator\n  if (stream.match(/^[-+]?\\d+(\\.\\d+)?([eE][-+]?\\d+)?/)) return \"number\";\n\n  // Handle Strings\n  if (ch == '\"') {\n    if (stream.skipTo('\"')) {\n      stream.next();\n      return \"string\";\n    } else {\n      stream.skipToEnd();\n      return \"error\";\n    }\n  }\n\n  // Handle operators and Delimiters\n  if (stream.match(doubleOperators) || stream.match(singleOperators)) return \"operator\";\n\n  // Prevents leading \".\" in DO block from falling through to error\n  if (stream.match(singleDelimiters)) return null;\n  if (brackets.test(ch)) {\n    stream.next();\n    return \"bracket\";\n  }\n  if (state.commandMode > 0 && stream.match(command)) return \"controlKeyword\";\n  if (stream.match(intrinsicFuncs)) return \"builtin\";\n  if (stream.match(identifiers)) return \"variable\";\n\n  // Detect dollar-sign when not a documented intrinsic function\n  // \"^\" may introduce a GVN or SSVN - Color same as function\n  if (ch === \"$\" || ch === \"^\") {\n    stream.next();\n    return \"builtin\";\n  }\n\n  // MUMPS Indirection\n  if (ch === \"@\") {\n    stream.next();\n    return \"string.special\";\n  }\n  if (/[\\w%]/.test(ch)) {\n    stream.eatWhile(/[\\w%]/);\n    return \"variable\";\n  }\n\n  // Handle non-detected items\n  stream.next();\n  return \"error\";\n}\nexport var mumps = {\n  name: \"mumps\",\n  startState: function startState() {\n    return {\n      label: false,\n      commandMode: 0\n    };\n  },\n  token: function token(stream, state) {\n    var style = tokenBase(stream, state);\n    if (state.label) return \"tag\";\n    return style;\n  }\n};"],"sourceRoot":""}