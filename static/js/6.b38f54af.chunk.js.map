{"version":3,"sources":["D:/react_app/app_1/node_modules/@codemirror/legacy-modes/mode/haxe.js"],"names":["kw","type","style","__webpack_require__","r","__webpack_exports__","d","haxe","hxml","content","A","B","C","operator","atom","attribute","keywords","if","while","else","do","try","return","break","continue","new","throw","var","inline","static","using","public","private","cast","import","macro","function","catch","untyped","callback","for","switch","case","default","in","never","trace","class","abstract","enum","interface","typedef","extends","implements","dynamic","true","false","null","isOperatorChar","chain","stream","state","f","tokenize","toUnescaped","end","next","escaped","ret","tp","cont","haxeTokenBase","ch","quote","test","eat","eatWhile","match","reAllowed","haxeTokenComment","skipToEnd","current","word","known","propertyIsEnumerable","kwAllowed","maybeEnd","atomicTypes","number","variable","string","regexp","HaxeLexical","indented","column","align","prev","info","this","inScope","varname","v","localVars","name","imported","typename","charAt","len","importedtypes","length","i","registerimport","importname","cx","t","marked","cc","pass","arguments","push","apply","inList","list","register","context","globalVars","defaultVars","pushcontext","vars","popcontext","pushlex","result","lexical","lex","poplex","expect","wanted","statement","metadef","vardef1","expression","block","maybeattribute","functiondef","forspec1","maybelabel","funarg","importdef","hasOwnProperty","maybeoperator","maybeexpression","commasep","objprop","value","property","metaargs","what","proceed","typeuse","vardef2","forin","_type","typestring","typeprop","startState","indentUnit","token","sol","indentation","eatSpace","pop","parseHaxe","indent","textAfter","firstChar","closing","unit","languageData","indentOnInput","commentTokens","line","open","close","define","inString","peek","skipTo"],"mappings":"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","file":"static/js/6.b38f54af.chunk.js","sourcesContent":["// Tokenizer\n\nfunction kw(type) {\n  return {\n    type: type,\n    style: \"keyword\"\n  };\n}\nvar A = kw(\"keyword a\"),\n  B = kw(\"keyword b\"),\n  C = kw(\"keyword c\");\nvar operator = kw(\"operator\"),\n  atom = {\n    type: \"atom\",\n    style: \"atom\"\n  },\n  attribute = {\n    type: \"attribute\",\n    style: \"attribute\"\n  };\nvar type = kw(\"typedef\");\nvar keywords = {\n  \"if\": A,\n  \"while\": A,\n  \"else\": B,\n  \"do\": B,\n  \"try\": B,\n  \"return\": C,\n  \"break\": C,\n  \"continue\": C,\n  \"new\": C,\n  \"throw\": C,\n  \"var\": kw(\"var\"),\n  \"inline\": attribute,\n  \"static\": attribute,\n  \"using\": kw(\"import\"),\n  \"public\": attribute,\n  \"private\": attribute,\n  \"cast\": kw(\"cast\"),\n  \"import\": kw(\"import\"),\n  \"macro\": kw(\"macro\"),\n  \"function\": kw(\"function\"),\n  \"catch\": kw(\"catch\"),\n  \"untyped\": kw(\"untyped\"),\n  \"callback\": kw(\"cb\"),\n  \"for\": kw(\"for\"),\n  \"switch\": kw(\"switch\"),\n  \"case\": kw(\"case\"),\n  \"default\": kw(\"default\"),\n  \"in\": operator,\n  \"never\": kw(\"property_access\"),\n  \"trace\": kw(\"trace\"),\n  \"class\": type,\n  \"abstract\": type,\n  \"enum\": type,\n  \"interface\": type,\n  \"typedef\": type,\n  \"extends\": type,\n  \"implements\": type,\n  \"dynamic\": type,\n  \"true\": atom,\n  \"false\": atom,\n  \"null\": atom\n};\nvar isOperatorChar = /[+\\-*&%=<>!?|]/;\nfunction chain(stream, state, f) {\n  state.tokenize = f;\n  return f(stream, state);\n}\nfunction toUnescaped(stream, end) {\n  var escaped = false,\n    next;\n  while ((next = stream.next()) != null) {\n    if (next == end && !escaped) return true;\n    escaped = !escaped && next == \"\\\\\";\n  }\n}\n\n// Used as scratch variables to communicate multiple values without\n// consing up tons of objects.\nvar type, content;\nfunction ret(tp, style, cont) {\n  type = tp;\n  content = cont;\n  return style;\n}\nfunction haxeTokenBase(stream, state) {\n  var ch = stream.next();\n  if (ch == '\"' || ch == \"'\") {\n    return chain(stream, state, haxeTokenString(ch));\n  } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n    return ret(ch);\n  } else if (ch == \"0\" && stream.eat(/x/i)) {\n    stream.eatWhile(/[\\da-f]/i);\n    return ret(\"number\", \"number\");\n  } else if (/\\d/.test(ch) || ch == \"-\" && stream.eat(/\\d/)) {\n    stream.match(/^\\d*(?:\\.\\d*(?!\\.))?(?:[eE][+\\-]?\\d+)?/);\n    return ret(\"number\", \"number\");\n  } else if (state.reAllowed && ch == \"~\" && stream.eat(/\\//)) {\n    toUnescaped(stream, \"/\");\n    stream.eatWhile(/[gimsu]/);\n    return ret(\"regexp\", \"string.special\");\n  } else if (ch == \"/\") {\n    if (stream.eat(\"*\")) {\n      return chain(stream, state, haxeTokenComment);\n    } else if (stream.eat(\"/\")) {\n      stream.skipToEnd();\n      return ret(\"comment\", \"comment\");\n    } else {\n      stream.eatWhile(isOperatorChar);\n      return ret(\"operator\", null, stream.current());\n    }\n  } else if (ch == \"#\") {\n    stream.skipToEnd();\n    return ret(\"conditional\", \"meta\");\n  } else if (ch == \"@\") {\n    stream.eat(/:/);\n    stream.eatWhile(/[\\w_]/);\n    return ret(\"metadata\", \"meta\");\n  } else if (isOperatorChar.test(ch)) {\n    stream.eatWhile(isOperatorChar);\n    return ret(\"operator\", null, stream.current());\n  } else {\n    var word;\n    if (/[A-Z]/.test(ch)) {\n      stream.eatWhile(/[\\w_<>]/);\n      word = stream.current();\n      return ret(\"type\", \"type\", word);\n    } else {\n      stream.eatWhile(/[\\w_]/);\n      var word = stream.current(),\n        known = keywords.propertyIsEnumerable(word) && keywords[word];\n      return known && state.kwAllowed ? ret(known.type, known.style, word) : ret(\"variable\", \"variable\", word);\n    }\n  }\n}\nfunction haxeTokenString(quote) {\n  return function (stream, state) {\n    if (toUnescaped(stream, quote)) state.tokenize = haxeTokenBase;\n    return ret(\"string\", \"string\");\n  };\n}\nfunction haxeTokenComment(stream, state) {\n  var maybeEnd = false,\n    ch;\n  while (ch = stream.next()) {\n    if (ch == \"/\" && maybeEnd) {\n      state.tokenize = haxeTokenBase;\n      break;\n    }\n    maybeEnd = ch == \"*\";\n  }\n  return ret(\"comment\", \"comment\");\n}\n\n// Parser\n\nvar atomicTypes = {\n  \"atom\": true,\n  \"number\": true,\n  \"variable\": true,\n  \"string\": true,\n  \"regexp\": true\n};\nfunction HaxeLexical(indented, column, type, align, prev, info) {\n  this.indented = indented;\n  this.column = column;\n  this.type = type;\n  this.prev = prev;\n  this.info = info;\n  if (align != null) this.align = align;\n}\nfunction inScope(state, varname) {\n  for (var v = state.localVars; v; v = v.next) if (v.name == varname) return true;\n}\nfunction parseHaxe(state, style, type, content, stream) {\n  var cc = state.cc;\n  // Communicate our context to the combinators.\n  // (Less wasteful than consing up a hundred closures on every call.)\n  cx.state = state;\n  cx.stream = stream;\n  cx.marked = null, cx.cc = cc;\n  if (!state.lexical.hasOwnProperty(\"align\")) state.lexical.align = true;\n  while (true) {\n    var combinator = cc.length ? cc.pop() : statement;\n    if (combinator(type, content)) {\n      while (cc.length && cc[cc.length - 1].lex) cc.pop()();\n      if (cx.marked) return cx.marked;\n      if (type == \"variable\" && inScope(state, content)) return \"variableName.local\";\n      if (type == \"variable\" && imported(state, content)) return \"variableName.special\";\n      return style;\n    }\n  }\n}\nfunction imported(state, typename) {\n  if (/[a-z]/.test(typename.charAt(0))) return false;\n  var len = state.importedtypes.length;\n  for (var i = 0; i < len; i++) if (state.importedtypes[i] == typename) return true;\n}\nfunction registerimport(importname) {\n  var state = cx.state;\n  for (var t = state.importedtypes; t; t = t.next) if (t.name == importname) return;\n  state.importedtypes = {\n    name: importname,\n    next: state.importedtypes\n  };\n}\n// Combinator utils\n\nvar cx = {\n  state: null,\n  column: null,\n  marked: null,\n  cc: null\n};\nfunction pass() {\n  for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n}\nfunction cont() {\n  pass.apply(null, arguments);\n  return true;\n}\nfunction inList(name, list) {\n  for (var v = list; v; v = v.next) if (v.name == name) return true;\n  return false;\n}\nfunction register(varname) {\n  var state = cx.state;\n  if (state.context) {\n    cx.marked = \"def\";\n    if (inList(varname, state.localVars)) return;\n    state.localVars = {\n      name: varname,\n      next: state.localVars\n    };\n  } else if (state.globalVars) {\n    if (inList(varname, state.globalVars)) return;\n    state.globalVars = {\n      name: varname,\n      next: state.globalVars\n    };\n  }\n}\n\n// Combinators\n\nvar defaultVars = {\n  name: \"this\",\n  next: null\n};\nfunction pushcontext() {\n  if (!cx.state.context) cx.state.localVars = defaultVars;\n  cx.state.context = {\n    prev: cx.state.context,\n    vars: cx.state.localVars\n  };\n}\nfunction popcontext() {\n  cx.state.localVars = cx.state.context.vars;\n  cx.state.context = cx.state.context.prev;\n}\npopcontext.lex = true;\nfunction pushlex(type, info) {\n  var result = function result() {\n    var state = cx.state;\n    state.lexical = new HaxeLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);\n  };\n  result.lex = true;\n  return result;\n}\nfunction poplex() {\n  var state = cx.state;\n  if (state.lexical.prev) {\n    if (state.lexical.type == \")\") state.indented = state.lexical.indented;\n    state.lexical = state.lexical.prev;\n  }\n}\npoplex.lex = true;\nfunction expect(wanted) {\n  function f(type) {\n    if (type == wanted) return cont();else if (wanted == \";\") return pass();else return cont(f);\n  }\n  return f;\n}\nfunction statement(type) {\n  if (type == \"@\") return cont(metadef);\n  if (type == \"var\") return cont(pushlex(\"vardef\"), vardef1, expect(\";\"), poplex);\n  if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n  if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n  if (type == \"{\") return cont(pushlex(\"}\"), pushcontext, block, poplex, popcontext);\n  if (type == \";\") return cont();\n  if (type == \"attribute\") return cont(maybeattribute);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"for\") return cont(pushlex(\"form\"), expect(\"(\"), pushlex(\")\"), forspec1, expect(\")\"), poplex, statement, poplex);\n  if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n  if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"), block, poplex, poplex);\n  if (type == \"case\") return cont(expression, expect(\":\"));\n  if (type == \"default\") return cont(expect(\":\"));\n  if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"), statement, poplex, popcontext);\n  if (type == \"import\") return cont(importdef, expect(\";\"));\n  if (type == \"typedef\") return cont(typedef);\n  return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n}\nfunction expression(type) {\n  if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);\n  if (type == \"type\") return cont(maybeoperator);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"keyword c\") return cont(maybeexpression);\n  if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeoperator);\n  if (type == \"operator\") return cont(expression);\n  if (type == \"[\") return cont(pushlex(\"]\"), commasep(maybeexpression, \"]\"), poplex, maybeoperator);\n  if (type == \"{\") return cont(pushlex(\"}\"), commasep(objprop, \"}\"), poplex, maybeoperator);\n  return cont();\n}\nfunction maybeexpression(type) {\n  if (type.match(/[;\\}\\)\\],]/)) return pass();\n  return pass(expression);\n}\nfunction maybeoperator(type, value) {\n  if (type == \"operator\" && /\\+\\+|--/.test(value)) return cont(maybeoperator);\n  if (type == \"operator\" || type == \":\") return cont(expression);\n  if (type == \";\") return;\n  if (type == \"(\") return cont(pushlex(\")\"), commasep(expression, \")\"), poplex, maybeoperator);\n  if (type == \".\") return cont(property, maybeoperator);\n  if (type == \"[\") return cont(pushlex(\"]\"), expression, expect(\"]\"), poplex, maybeoperator);\n}\nfunction maybeattribute(type) {\n  if (type == \"attribute\") return cont(maybeattribute);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"var\") return cont(vardef1);\n}\nfunction metadef(type) {\n  if (type == \":\") return cont(metadef);\n  if (type == \"variable\") return cont(metadef);\n  if (type == \"(\") return cont(pushlex(\")\"), commasep(metaargs, \")\"), poplex, statement);\n}\nfunction metaargs(type) {\n  if (type == \"variable\") return cont();\n}\nfunction importdef(type, value) {\n  if (type == \"variable\" && /[A-Z]/.test(value.charAt(0))) {\n    registerimport(value);\n    return cont();\n  } else if (type == \"variable\" || type == \"property\" || type == \".\" || value == \"*\") return cont(importdef);\n}\nfunction typedef(type, value) {\n  if (type == \"variable\" && /[A-Z]/.test(value.charAt(0))) {\n    registerimport(value);\n    return cont();\n  } else if (type == \"type\" && /[A-Z]/.test(value.charAt(0))) {\n    return cont();\n  }\n}\nfunction maybelabel(type) {\n  if (type == \":\") return cont(poplex, statement);\n  return pass(maybeoperator, expect(\";\"), poplex);\n}\nfunction property(type) {\n  if (type == \"variable\") {\n    cx.marked = \"property\";\n    return cont();\n  }\n}\nfunction objprop(type) {\n  if (type == \"variable\") cx.marked = \"property\";\n  if (atomicTypes.hasOwnProperty(type)) return cont(expect(\":\"), expression);\n}\nfunction commasep(what, end) {\n  function proceed(type) {\n    if (type == \",\") return cont(what, proceed);\n    if (type == end) return cont();\n    return cont(expect(end));\n  }\n  return function (type) {\n    if (type == end) return cont();else return pass(what, proceed);\n  };\n}\nfunction block(type) {\n  if (type == \"}\") return cont();\n  return pass(statement, block);\n}\nfunction vardef1(type, value) {\n  if (type == \"variable\") {\n    register(value);\n    return cont(typeuse, vardef2);\n  }\n  return cont();\n}\nfunction vardef2(type, value) {\n  if (value == \"=\") return cont(expression, vardef2);\n  if (type == \",\") return cont(vardef1);\n}\nfunction forspec1(type, value) {\n  if (type == \"variable\") {\n    register(value);\n    return cont(forin, expression);\n  } else {\n    return pass();\n  }\n}\nfunction forin(_type, value) {\n  if (value == \"in\") return cont();\n}\nfunction functiondef(type, value) {\n  //function names starting with upper-case letters are recognised as types, so cludging them together here.\n  if (type == \"variable\" || type == \"type\") {\n    register(value);\n    return cont(functiondef);\n  }\n  if (value == \"new\") return cont(functiondef);\n  if (type == \"(\") return cont(pushlex(\")\"), pushcontext, commasep(funarg, \")\"), poplex, typeuse, statement, popcontext);\n}\nfunction typeuse(type) {\n  if (type == \":\") return cont(typestring);\n}\nfunction typestring(type) {\n  if (type == \"type\") return cont();\n  if (type == \"variable\") return cont();\n  if (type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\"), poplex);\n}\nfunction typeprop(type) {\n  if (type == \"variable\") return cont(typeuse);\n}\nfunction funarg(type, value) {\n  if (type == \"variable\") {\n    register(value);\n    return cont(typeuse);\n  }\n}\n\n// Interface\nexport var haxe = {\n  name: \"haxe\",\n  startState: function startState(indentUnit) {\n    var defaulttypes = [\"Int\", \"Float\", \"String\", \"Void\", \"Std\", \"Bool\", \"Dynamic\", \"Array\"];\n    var state = {\n      tokenize: haxeTokenBase,\n      reAllowed: true,\n      kwAllowed: true,\n      cc: [],\n      lexical: new HaxeLexical(-indentUnit, 0, \"block\", false),\n      importedtypes: defaulttypes,\n      context: null,\n      indented: 0\n    };\n    return state;\n  },\n  token: function token(stream, state) {\n    if (stream.sol()) {\n      if (!state.lexical.hasOwnProperty(\"align\")) state.lexical.align = false;\n      state.indented = stream.indentation();\n    }\n    if (stream.eatSpace()) return null;\n    var style = state.tokenize(stream, state);\n    if (type == \"comment\") return style;\n    state.reAllowed = !!(type == \"operator\" || type == \"keyword c\" || type.match(/^[\\[{}\\(,;:]$/));\n    state.kwAllowed = type != '.';\n    return parseHaxe(state, style, type, content, stream);\n  },\n  indent: function indent(state, textAfter, cx) {\n    if (state.tokenize != haxeTokenBase) return 0;\n    var firstChar = textAfter && textAfter.charAt(0),\n      lexical = state.lexical;\n    if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n    var type = lexical.type,\n      closing = firstChar == type;\n    if (type == \"vardef\") return lexical.indented + 4;else if (type == \"form\" && firstChar == \"{\") return lexical.indented;else if (type == \"stat\" || type == \"form\") return lexical.indented + cx.unit;else if (lexical.info == \"switch\" && !closing) return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? cx.unit : 2 * cx.unit);else if (lexical.align) return lexical.column + (closing ? 0 : 1);else return lexical.indented + (closing ? 0 : cx.unit);\n  },\n  languageData: {\n    indentOnInput: /^\\s*[{}]$/,\n    commentTokens: {\n      line: \"//\",\n      block: {\n        open: \"/*\",\n        close: \"*/\"\n      }\n    }\n  }\n};\nexport var hxml = {\n  name: \"hxml\",\n  startState: function startState() {\n    return {\n      define: false,\n      inString: false\n    };\n  },\n  token: function token(stream, state) {\n    var ch = stream.peek();\n    var sol = stream.sol();\n\n    ///* comments */\n    if (ch == \"#\") {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n    if (sol && ch == \"-\") {\n      var style = \"variable-2\";\n      stream.eat(/-/);\n      if (stream.peek() == \"-\") {\n        stream.eat(/-/);\n        style = \"keyword a\";\n      }\n      if (stream.peek() == \"D\") {\n        stream.eat(/[D]/);\n        style = \"keyword c\";\n        state.define = true;\n      }\n      stream.eatWhile(/[A-Z]/i);\n      return style;\n    }\n    var ch = stream.peek();\n    if (state.inString == false && ch == \"'\") {\n      state.inString = true;\n      stream.next();\n    }\n    if (state.inString == true) {\n      if (stream.skipTo(\"'\")) {} else {\n        stream.skipToEnd();\n      }\n      if (stream.peek() == \"'\") {\n        stream.next();\n        state.inString = false;\n      }\n      return \"string\";\n    }\n    stream.next();\n    return null;\n  },\n  languageData: {\n    commentTokens: {\n      line: \"#\"\n    }\n  }\n};"],"sourceRoot":""}