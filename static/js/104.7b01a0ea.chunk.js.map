{"version":3,"sources":["D:/react_app/app_1/node_modules/@codemirror/legacy-modes/mode/webidl.js"],"names":["wordRegexp","words","RegExp","join","__webpack_require__","r","__webpack_exports__","d","webIDL","builtinArray","builtins","typeArray","types","keywordArray","keywords","atomArray","atoms","startDefs","endDefs","singleOperators","integers","floats","identifiers","identifiersEnd","strings","multilineComments","multilineCommentsStart","multilineCommentsEnd","name","startState","inComment","lastToken","startDef","endDef","token","stream","state","style","eatSpace","match","skipToEnd","nextToken","next","readToken","cur","current","test","languageData","autocomplete","concat"],"mappings":"4FAAA,SAAAA,EAAAC,GACA,WAAAC,OAAA,MAAAD,EAAAE,KAAA,gBADAC,EAAAC,EAAAC,GAAAF,EAAAG,EAAAD,EAAA,2BAAAE,IAIA,IAAAC,EAAA,4VACAC,EAAAV,EAAAS,GACAE,EAAA,2BAEA,gCAEA,yBAEA,UAEA,0JAEA,uGAEA,MAEA,QAGAC,EAAAZ,EAAAW,GACAE,EAAA,oOAGA,4BACAC,EAAAd,EAAAa,GACAE,EAAA,gBAEA,iBAEA,QAGAC,EAAAhB,EAAAe,GAEAE,EAAAjB,EADA,8CAGAkB,EAAAlB,EADA,aAEAmB,EAAA,WACAC,EAAA,6CACAC,EAAA,+EACAC,EAAA,4BACAC,EAAA,oCACAC,EAAA,WACAC,EAAA,eACAC,EAAA,UACAC,EAAA,WA8DO,IAAAnB,EAAA,CACPoB,KAAA,SACAC,WAAA,WACA,OAEAC,WAAA,EAEAC,UAAA,GAEAC,UAAA,EAEAC,QAAA,IAGAC,MAAA,SAAAC,EAAAC,GACA,IAAAC,EA5EA,SAAAF,EAAAC,GAEA,GAAAD,EAAAG,WAAA,YAGA,GAAAF,EAAAN,UACA,OAAAK,EAAAI,MAAAZ,IACAS,EAAAN,WAAA,EACA,YAEAK,EAAAK,YACA,WAEA,GAAAL,EAAAI,MAAA,MAEA,OADAJ,EAAAK,YACA,UAEA,GAAAL,EAAAI,MAAAd,GAAA,gBACA,GAAAU,EAAAI,MAAAb,GAEA,OADAU,EAAAN,WAAA,EACA,UAIA,GAAAK,EAAAI,MAAA,mBACAJ,EAAAI,MAAAnB,IAAAe,EAAAI,MAAAlB,IAAA,eAIA,GAAAc,EAAAI,MAAAf,GAAA,eAGA,GAAAY,EAAAJ,UAAAG,EAAAI,MAAAjB,GAAA,YACA,GAAAc,EAAAH,QAAAE,EAAAI,MAAAhB,GAEA,OADAa,EAAAH,QAAA,EACA,MAEA,GAAAE,EAAAI,MAAAzB,GAAA,gBACA,GAAAqB,EAAAI,MAAA3B,GAAA,CACA,IAAAmB,EAAAK,EAAAL,UACAU,GAAAN,EAAAI,MAAA,0BACA,YAAAR,GAAA,eAAAA,GAAA,eAAAU,GAAA,MAAAA,EAEA,UAGA,OAGA,OAAAN,EAAAI,MAAA7B,GAAA,UACAyB,EAAAI,MAAAvB,GAAA,OACAmB,EAAAI,MAAAjB,GAAA,WAGAa,EAAAI,MAAApB,GAAA,YAGAgB,EAAAO,OACA,MAkBAC,CAAAR,EAAAC,GACA,GAAAC,EAAA,CACA,IAAAO,EAAAT,EAAAU,UACAT,EAAAL,UAAAa,EACA,YAAAP,GACAD,EAAAJ,SAAAf,EAAA6B,KAAAF,GACAR,EAAAH,OAAAG,EAAAH,QAAAf,EAAA4B,KAAAF,IAEAR,EAAAJ,UAAA,EAGA,OAAAK,GAEAU,aAAA,CACAC,aAAAvC,EAAAwC,OAAAtC,GAAAsC,OAAApC,GAAAoC,OAAAlC","file":"static/js/104.7b01a0ea.chunk.js","sourcesContent":["function wordRegexp(words) {\n  return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n}\n;\nvar builtinArray = [\"Clamp\", \"Constructor\", \"EnforceRange\", \"Exposed\", \"ImplicitThis\", \"Global\", \"PrimaryGlobal\", \"LegacyArrayClass\", \"LegacyUnenumerableNamedProperties\", \"LenientThis\", \"NamedConstructor\", \"NewObject\", \"NoInterfaceObject\", \"OverrideBuiltins\", \"PutForwards\", \"Replaceable\", \"SameObject\", \"TreatNonObjectAsNull\", \"TreatNullAs\", \"EmptyString\", \"Unforgeable\", \"Unscopeable\"];\nvar builtins = wordRegexp(builtinArray);\nvar typeArray = [\"unsigned\", \"short\", \"long\",\n// UnsignedIntegerType\n\"unrestricted\", \"float\", \"double\",\n// UnrestrictedFloatType\n\"boolean\", \"byte\", \"octet\",\n// Rest of PrimitiveType\n\"Promise\",\n// PromiseType\n\"ArrayBuffer\", \"DataView\", \"Int8Array\", \"Int16Array\", \"Int32Array\", \"Uint8Array\", \"Uint16Array\", \"Uint32Array\", \"Uint8ClampedArray\", \"Float32Array\", \"Float64Array\",\n// BufferRelatedType\n\"ByteString\", \"DOMString\", \"USVString\", \"sequence\", \"object\", \"RegExp\", \"Error\", \"DOMException\", \"FrozenArray\",\n// Rest of NonAnyType\n\"any\",\n// Rest of SingleType\n\"void\" // Rest of ReturnType\n];\n\nvar types = wordRegexp(typeArray);\nvar keywordArray = [\"attribute\", \"callback\", \"const\", \"deleter\", \"dictionary\", \"enum\", \"getter\", \"implements\", \"inherit\", \"interface\", \"iterable\", \"legacycaller\", \"maplike\", \"partial\", \"required\", \"serializer\", \"setlike\", \"setter\", \"static\", \"stringifier\", \"typedef\",\n// ArgumentNameKeyword except\n// \"unrestricted\"\n\"optional\", \"readonly\", \"or\"];\nvar keywords = wordRegexp(keywordArray);\nvar atomArray = [\"true\", \"false\",\n// BooleanLiteral\n\"Infinity\", \"NaN\",\n// FloatLiteral\n\"null\" // Rest of ConstValue\n];\n\nvar atoms = wordRegexp(atomArray);\nvar startDefArray = [\"callback\", \"dictionary\", \"enum\", \"interface\"];\nvar startDefs = wordRegexp(startDefArray);\nvar endDefArray = [\"typedef\"];\nvar endDefs = wordRegexp(endDefArray);\nvar singleOperators = /^[:<=>?]/;\nvar integers = /^-?([1-9][0-9]*|0[Xx][0-9A-Fa-f]+|0[0-7]*)/;\nvar floats = /^-?(([0-9]+\\.[0-9]*|[0-9]*\\.[0-9]+)([Ee][+-]?[0-9]+)?|[0-9]+[Ee][+-]?[0-9]+)/;\nvar identifiers = /^_?[A-Za-z][0-9A-Z_a-z-]*/;\nvar identifiersEnd = /^_?[A-Za-z][0-9A-Z_a-z-]*(?=\\s*;)/;\nvar strings = /^\"[^\"]*\"/;\nvar multilineComments = /^\\/\\*.*?\\*\\//;\nvar multilineCommentsStart = /^\\/\\*.*/;\nvar multilineCommentsEnd = /^.*?\\*\\//;\nfunction readToken(stream, state) {\n  // whitespace\n  if (stream.eatSpace()) return null;\n\n  // comment\n  if (state.inComment) {\n    if (stream.match(multilineCommentsEnd)) {\n      state.inComment = false;\n      return \"comment\";\n    }\n    stream.skipToEnd();\n    return \"comment\";\n  }\n  if (stream.match(\"//\")) {\n    stream.skipToEnd();\n    return \"comment\";\n  }\n  if (stream.match(multilineComments)) return \"comment\";\n  if (stream.match(multilineCommentsStart)) {\n    state.inComment = true;\n    return \"comment\";\n  }\n\n  // integer and float\n  if (stream.match(/^-?[0-9\\.]/, false)) {\n    if (stream.match(integers) || stream.match(floats)) return \"number\";\n  }\n\n  // string\n  if (stream.match(strings)) return \"string\";\n\n  // identifier\n  if (state.startDef && stream.match(identifiers)) return \"def\";\n  if (state.endDef && stream.match(identifiersEnd)) {\n    state.endDef = false;\n    return \"def\";\n  }\n  if (stream.match(keywords)) return \"keyword\";\n  if (stream.match(types)) {\n    var lastToken = state.lastToken;\n    var nextToken = (stream.match(/^\\s*(.+?)\\b/, false) || [])[1];\n    if (lastToken === \":\" || lastToken === \"implements\" || nextToken === \"implements\" || nextToken === \"=\") {\n      // Used as identifier\n      return \"builtin\";\n    } else {\n      // Used as type\n      return \"type\";\n    }\n  }\n  if (stream.match(builtins)) return \"builtin\";\n  if (stream.match(atoms)) return \"atom\";\n  if (stream.match(identifiers)) return \"variable\";\n\n  // other\n  if (stream.match(singleOperators)) return \"operator\";\n\n  // unrecognized\n  stream.next();\n  return null;\n}\n;\nexport var webIDL = {\n  name: \"webidl\",\n  startState: function startState() {\n    return {\n      // Is in multiline comment\n      inComment: false,\n      // Last non-whitespace, matched token\n      lastToken: \"\",\n      // Next token is a definition\n      startDef: false,\n      // Last token of the statement is a definition\n      endDef: false\n    };\n  },\n  token: function token(stream, state) {\n    var style = readToken(stream, state);\n    if (style) {\n      var cur = stream.current();\n      state.lastToken = cur;\n      if (style === \"keyword\") {\n        state.startDef = startDefs.test(cur);\n        state.endDef = state.endDef || endDefs.test(cur);\n      } else {\n        state.startDef = false;\n      }\n    }\n    return style;\n  },\n  languageData: {\n    autocomplete: builtinArray.concat(typeArray).concat(keywordArray).concat(atomArray)\n  }\n};"],"sourceRoot":""}