{"version":3,"sources":["D:/react_app/app_1/node_modules/@codemirror/legacy-modes/mode/dtd.js"],"names":["type","ret","style","tp","tokenBase","stream","state","quote","terminator","ch","next","eat","tokenize","eol","match","eatWhile","escaped","sc","current","substr","length","backUp","tokenSGMLComment","dashes","__webpack_require__","r","__webpack_exports__","d","dtd","name","startState","baseIndent","stack","token","eatSpace","context","push","pop","indent","textAfter","cx","n","charAt","unit","languageData","indentOnInput"],"mappings":"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","file":"static/js/37.f2597513.chunk.js","sourcesContent":["var type;\nfunction ret(style, tp) {\n  type = tp;\n  return style;\n}\nfunction tokenBase(stream, state) {\n  var ch = stream.next();\n  if (ch == \"<\" && stream.eat(\"!\")) {\n    if (stream.eatWhile(/[\\-]/)) {\n      state.tokenize = tokenSGMLComment;\n      return tokenSGMLComment(stream, state);\n    } else if (stream.eatWhile(/[\\w]/)) return ret(\"keyword\", \"doindent\");\n  } else if (ch == \"<\" && stream.eat(\"?\")) {\n    //xml declaration\n    state.tokenize = inBlock(\"meta\", \"?>\");\n    return ret(\"meta\", ch);\n  } else if (ch == \"#\" && stream.eatWhile(/[\\w]/)) return ret(\"atom\", \"tag\");else if (ch == \"|\") return ret(\"keyword\", \"separator\");else if (ch.match(/[\\(\\)\\[\\]\\-\\.,\\+\\?>]/)) return ret(null, ch); //if(ch === \">\") return ret(null, \"endtag\"); else\n  else if (ch.match(/[\\[\\]]/)) return ret(\"rule\", ch);else if (ch == \"\\\"\" || ch == \"'\") {\n    state.tokenize = tokenString(ch);\n    return state.tokenize(stream, state);\n  } else if (stream.eatWhile(/[a-zA-Z\\?\\+\\d]/)) {\n    var sc = stream.current();\n    if (sc.substr(sc.length - 1, sc.length).match(/\\?|\\+/) !== null) stream.backUp(1);\n    return ret(\"tag\", \"tag\");\n  } else if (ch == \"%\" || ch == \"*\") return ret(\"number\", \"number\");else {\n    stream.eatWhile(/[\\w\\\\\\-_%.{,]/);\n    return ret(null, null);\n  }\n}\nfunction tokenSGMLComment(stream, state) {\n  var dashes = 0,\n    ch;\n  while ((ch = stream.next()) != null) {\n    if (dashes >= 2 && ch == \">\") {\n      state.tokenize = tokenBase;\n      break;\n    }\n    dashes = ch == \"-\" ? dashes + 1 : 0;\n  }\n  return ret(\"comment\", \"comment\");\n}\nfunction tokenString(quote) {\n  return function (stream, state) {\n    var escaped = false,\n      ch;\n    while ((ch = stream.next()) != null) {\n      if (ch == quote && !escaped) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && ch == \"\\\\\";\n    }\n    return ret(\"string\", \"tag\");\n  };\n}\nfunction inBlock(style, terminator) {\n  return function (stream, state) {\n    while (!stream.eol()) {\n      if (stream.match(terminator)) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      stream.next();\n    }\n    return style;\n  };\n}\nexport var dtd = {\n  name: \"dtd\",\n  startState: function startState() {\n    return {\n      tokenize: tokenBase,\n      baseIndent: 0,\n      stack: []\n    };\n  },\n  token: function token(stream, state) {\n    if (stream.eatSpace()) return null;\n    var style = state.tokenize(stream, state);\n    var context = state.stack[state.stack.length - 1];\n    if (stream.current() == \"[\" || type === \"doindent\" || type == \"[\") state.stack.push(\"rule\");else if (type === \"endtag\") state.stack[state.stack.length - 1] = \"endtag\";else if (stream.current() == \"]\" || type == \"]\" || type == \">\" && context == \"rule\") state.stack.pop();else if (type == \"[\") state.stack.push(\"[\");\n    return style;\n  },\n  indent: function indent(state, textAfter, cx) {\n    var n = state.stack.length;\n    if (textAfter.charAt(0) === ']') n--;else if (textAfter.substr(textAfter.length - 1, textAfter.length) === \">\") {\n      if (textAfter.substr(0, 1) === \"<\") {} else if (type == \"doindent\" && textAfter.length > 1) {} else if (type == \"doindent\") n--;else if (type == \">\" && textAfter.length > 1) {} else if (type == \"tag\" && textAfter !== \">\") {} else if (type == \"tag\" && state.stack[state.stack.length - 1] == \"rule\") n--;else if (type == \"tag\") n++;else if (textAfter === \">\" && state.stack[state.stack.length - 1] == \"rule\" && type === \">\") n--;else if (textAfter === \">\" && state.stack[state.stack.length - 1] == \"rule\") {} else if (textAfter.substr(0, 1) !== \"<\" && textAfter.substr(0, 1) === \">\") n = n - 1;else if (textAfter === \">\") {} else n = n - 1;\n      //over rule them all\n      if (type == null || type == \"]\") n--;\n    }\n    return state.baseIndent + n * cx.unit;\n  },\n  languageData: {\n    indentOnInput: /^\\s*[\\]>]$/\n  }\n};"],"sourceRoot":""}