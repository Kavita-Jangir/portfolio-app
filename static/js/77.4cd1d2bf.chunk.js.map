{"version":3,"sources":["D:/react_app/app_1/node_modules/@codemirror/legacy-modes/mode/r.js"],"names":["wordObj","words","res","i","length","__webpack_require__","r","__webpack_exports__","d","curPunc","commonAtoms","commonBuiltins","commonKeywords","atoms","builtins","keywords","blockkeywords","opChars","tokenBase","stream","state","quote","ch","next","skipToEnd","eat","eatWhile","match","test","tokenize","skipTo","backUp","word","current","propertyIsEnumerable","ctx","argList","push","type","indent","flags","column","prev","setFlag","flag","pop","name","startState","indentUnit","afterIdent","token","sol","indentation","eatSpace","style","textAfter","cx","firstChar","charAt","closing","unit","languageData","wordChars","commentTokens","line","autocomplete","concat"],"mappings":"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","file":"static/js/77.4cd1d2bf.chunk.js","sourcesContent":["function wordObj(words) {\n  var res = {};\n  for (var i = 0; i < words.length; ++i) res[words[i]] = true;\n  return res;\n}\nvar commonAtoms = [\"NULL\", \"NA\", \"Inf\", \"NaN\", \"NA_integer_\", \"NA_real_\", \"NA_complex_\", \"NA_character_\", \"TRUE\", \"FALSE\"];\nvar commonBuiltins = [\"list\", \"quote\", \"bquote\", \"eval\", \"return\", \"call\", \"parse\", \"deparse\"];\nvar commonKeywords = [\"if\", \"else\", \"repeat\", \"while\", \"function\", \"for\", \"in\", \"next\", \"break\"];\nvar commonBlockKeywords = [\"if\", \"else\", \"repeat\", \"while\", \"function\", \"for\"];\nvar atoms = wordObj(commonAtoms);\nvar builtins = wordObj(commonBuiltins);\nvar keywords = wordObj(commonKeywords);\nvar blockkeywords = wordObj(commonBlockKeywords);\nvar opChars = /[+\\-*\\/^<>=!&|~$:]/;\nvar curPunc;\nfunction tokenBase(stream, state) {\n  curPunc = null;\n  var ch = stream.next();\n  if (ch == \"#\") {\n    stream.skipToEnd();\n    return \"comment\";\n  } else if (ch == \"0\" && stream.eat(\"x\")) {\n    stream.eatWhile(/[\\da-f]/i);\n    return \"number\";\n  } else if (ch == \".\" && stream.eat(/\\d/)) {\n    stream.match(/\\d*(?:e[+\\-]?\\d+)?/);\n    return \"number\";\n  } else if (/\\d/.test(ch)) {\n    stream.match(/\\d*(?:\\.\\d+)?(?:e[+\\-]\\d+)?L?/);\n    return \"number\";\n  } else if (ch == \"'\" || ch == '\"') {\n    state.tokenize = tokenString(ch);\n    return \"string\";\n  } else if (ch == \"`\") {\n    stream.match(/[^`]+`/);\n    return \"string.special\";\n  } else if (ch == \".\" && stream.match(/.(?:[.]|\\d+)/)) {\n    return \"keyword\";\n  } else if (/[a-zA-Z\\.]/.test(ch)) {\n    stream.eatWhile(/[\\w\\.]/);\n    var word = stream.current();\n    if (atoms.propertyIsEnumerable(word)) return \"atom\";\n    if (keywords.propertyIsEnumerable(word)) {\n      // Block keywords start new blocks, except 'else if', which only starts\n      // one new block for the 'if', no block for the 'else'.\n      if (blockkeywords.propertyIsEnumerable(word) && !stream.match(/\\s*if(\\s+|$)/, false)) curPunc = \"block\";\n      return \"keyword\";\n    }\n    if (builtins.propertyIsEnumerable(word)) return \"builtin\";\n    return \"variable\";\n  } else if (ch == \"%\") {\n    if (stream.skipTo(\"%\")) stream.next();\n    return \"variableName.special\";\n  } else if (ch == \"<\" && stream.eat(\"-\") || ch == \"<\" && stream.match(\"<-\") || ch == \"-\" && stream.match(/>>?/)) {\n    return \"operator\";\n  } else if (ch == \"=\" && state.ctx.argList) {\n    return \"operator\";\n  } else if (opChars.test(ch)) {\n    if (ch == \"$\") return \"operator\";\n    stream.eatWhile(opChars);\n    return \"operator\";\n  } else if (/[\\(\\){}\\[\\];]/.test(ch)) {\n    curPunc = ch;\n    if (ch == \";\") return \"punctuation\";\n    return null;\n  } else {\n    return null;\n  }\n}\nfunction tokenString(quote) {\n  return function (stream, state) {\n    if (stream.eat(\"\\\\\")) {\n      var ch = stream.next();\n      if (ch == \"x\") stream.match(/^[a-f0-9]{2}/i);else if ((ch == \"u\" || ch == \"U\") && stream.eat(\"{\") && stream.skipTo(\"}\")) stream.next();else if (ch == \"u\") stream.match(/^[a-f0-9]{4}/i);else if (ch == \"U\") stream.match(/^[a-f0-9]{8}/i);else if (/[0-7]/.test(ch)) stream.match(/^[0-7]{1,2}/);\n      return \"string.special\";\n    } else {\n      var next;\n      while ((next = stream.next()) != null) {\n        if (next == quote) {\n          state.tokenize = tokenBase;\n          break;\n        }\n        if (next == \"\\\\\") {\n          stream.backUp(1);\n          break;\n        }\n      }\n      return \"string\";\n    }\n  };\n}\nvar ALIGN_YES = 1,\n  ALIGN_NO = 2,\n  BRACELESS = 4;\nfunction push(state, type, stream) {\n  state.ctx = {\n    type: type,\n    indent: state.indent,\n    flags: 0,\n    column: stream.column(),\n    prev: state.ctx\n  };\n}\nfunction setFlag(state, flag) {\n  var ctx = state.ctx;\n  state.ctx = {\n    type: ctx.type,\n    indent: ctx.indent,\n    flags: ctx.flags | flag,\n    column: ctx.column,\n    prev: ctx.prev\n  };\n}\nfunction pop(state) {\n  state.indent = state.ctx.indent;\n  state.ctx = state.ctx.prev;\n}\nexport var r = {\n  name: \"r\",\n  startState: function startState(indentUnit) {\n    return {\n      tokenize: tokenBase,\n      ctx: {\n        type: \"top\",\n        indent: -indentUnit,\n        flags: ALIGN_NO\n      },\n      indent: 0,\n      afterIdent: false\n    };\n  },\n  token: function token(stream, state) {\n    if (stream.sol()) {\n      if ((state.ctx.flags & 3) == 0) state.ctx.flags |= ALIGN_NO;\n      if (state.ctx.flags & BRACELESS) pop(state);\n      state.indent = stream.indentation();\n    }\n    if (stream.eatSpace()) return null;\n    var style = state.tokenize(stream, state);\n    if (style != \"comment\" && (state.ctx.flags & ALIGN_NO) == 0) setFlag(state, ALIGN_YES);\n    if ((curPunc == \";\" || curPunc == \"{\" || curPunc == \"}\") && state.ctx.type == \"block\") pop(state);\n    if (curPunc == \"{\") push(state, \"}\", stream);else if (curPunc == \"(\") {\n      push(state, \")\", stream);\n      if (state.afterIdent) state.ctx.argList = true;\n    } else if (curPunc == \"[\") push(state, \"]\", stream);else if (curPunc == \"block\") push(state, \"block\", stream);else if (curPunc == state.ctx.type) pop(state);else if (state.ctx.type == \"block\" && style != \"comment\") setFlag(state, BRACELESS);\n    state.afterIdent = style == \"variable\" || style == \"keyword\";\n    return style;\n  },\n  indent: function indent(state, textAfter, cx) {\n    if (state.tokenize != tokenBase) return 0;\n    var firstChar = textAfter && textAfter.charAt(0),\n      ctx = state.ctx,\n      closing = firstChar == ctx.type;\n    if (ctx.flags & BRACELESS) ctx = ctx.prev;\n    if (ctx.type == \"block\") return ctx.indent + (firstChar == \"{\" ? 0 : cx.unit);else if (ctx.flags & ALIGN_YES) return ctx.column + (closing ? 0 : 1);else return ctx.indent + (closing ? 0 : cx.unit);\n  },\n  languageData: {\n    wordChars: \".\",\n    commentTokens: {\n      line: \"#\"\n    },\n    autocomplete: commonAtoms.concat(commonBuiltins, commonKeywords)\n  }\n};"],"sourceRoot":""}