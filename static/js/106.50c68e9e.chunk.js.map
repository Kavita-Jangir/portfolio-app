{"version":3,"sources":["D:/react_app/app_1/node_modules/@codemirror/legacy-modes/mode/yacas.js"],"names":["__webpack_require__","r","__webpack_exports__","d","yacas","bodiedOps","str","obj","words","split","i","length","pIdentifier","reFloatForm","RegExp","reIdentifier","rePattern","reFunctionLike","tokenBase","stream","state","ch","next","tokenize","tokenString","eat","tokenComment","skipToEnd","backUp","m","match","hasOwnProperty","scopes","push","scope","currentScope","pop","end","escaped","prev","name","startState","token","eatSpace","indent","textAfter","cx","delta","unit","languageData","electricInput","commentTokens","line","block","open","close"],"mappings":"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","file":"static/js/106.50c68e9e.chunk.js","sourcesContent":["function words(str) {\n  var obj = {},\n    words = str.split(\" \");\n  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n  return obj;\n}\nvar bodiedOps = words(\"Assert BackQuote D Defun Deriv For ForEach FromFile \" + \"FromString Function Integrate InverseTaylor Limit \" + \"LocalSymbols Macro MacroRule MacroRulePattern \" + \"NIntegrate Rule RulePattern Subst TD TExplicitSum \" + \"TSum Taylor Taylor1 Taylor2 Taylor3 ToFile \" + \"ToStdout ToString TraceRule Until While\");\n\n// patterns\nvar pFloatForm = \"(?:(?:\\\\.\\\\d+|\\\\d+\\\\.\\\\d*|\\\\d+)(?:[eE][+-]?\\\\d+)?)\";\nvar pIdentifier = \"(?:[a-zA-Z\\\\$'][a-zA-Z0-9\\\\$']*)\";\n\n// regular expressions\nvar reFloatForm = new RegExp(pFloatForm);\nvar reIdentifier = new RegExp(pIdentifier);\nvar rePattern = new RegExp(pIdentifier + \"?_\" + pIdentifier);\nvar reFunctionLike = new RegExp(pIdentifier + \"\\\\s*\\\\(\");\nfunction tokenBase(stream, state) {\n  var ch;\n\n  // get next character\n  ch = stream.next();\n\n  // string\n  if (ch === '\"') {\n    state.tokenize = tokenString;\n    return state.tokenize(stream, state);\n  }\n\n  // comment\n  if (ch === '/') {\n    if (stream.eat('*')) {\n      state.tokenize = tokenComment;\n      return state.tokenize(stream, state);\n    }\n    if (stream.eat(\"/\")) {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n  }\n\n  // go back one character\n  stream.backUp(1);\n\n  // update scope info\n  var m = stream.match(/^(\\w+)\\s*\\(/, false);\n  if (m !== null && bodiedOps.hasOwnProperty(m[1])) state.scopes.push('bodied');\n  var scope = currentScope(state);\n  if (scope === 'bodied' && ch === '[') state.scopes.pop();\n  if (ch === '[' || ch === '{' || ch === '(') state.scopes.push(ch);\n  scope = currentScope(state);\n  if (scope === '[' && ch === ']' || scope === '{' && ch === '}' || scope === '(' && ch === ')') state.scopes.pop();\n  if (ch === ';') {\n    while (scope === 'bodied') {\n      state.scopes.pop();\n      scope = currentScope(state);\n    }\n  }\n\n  // look for ordered rules\n  if (stream.match(/\\d+ *#/, true, false)) {\n    return 'qualifier';\n  }\n\n  // look for numbers\n  if (stream.match(reFloatForm, true, false)) {\n    return 'number';\n  }\n\n  // look for placeholders\n  if (stream.match(rePattern, true, false)) {\n    return 'variableName.special';\n  }\n\n  // match all braces separately\n  if (stream.match(/(?:\\[|\\]|{|}|\\(|\\))/, true, false)) {\n    return 'bracket';\n  }\n\n  // literals looking like function calls\n  if (stream.match(reFunctionLike, true, false)) {\n    stream.backUp(1);\n    return 'variableName.function';\n  }\n\n  // all other identifiers\n  if (stream.match(reIdentifier, true, false)) {\n    return 'variable';\n  }\n\n  // operators; note that operators like @@ or /; are matched separately for each symbol.\n  if (stream.match(/(?:\\\\|\\+|\\-|\\*|\\/|,|;|\\.|:|@|~|=|>|<|&|\\||_|`|'|\\^|\\?|!|%|#)/, true, false)) {\n    return 'operator';\n  }\n\n  // everything else is an error\n  return 'error';\n}\nfunction tokenString(stream, state) {\n  var next,\n    end = false,\n    escaped = false;\n  while ((next = stream.next()) != null) {\n    if (next === '\"' && !escaped) {\n      end = true;\n      break;\n    }\n    escaped = !escaped && next === '\\\\';\n  }\n  if (end && !escaped) {\n    state.tokenize = tokenBase;\n  }\n  return 'string';\n}\n;\nfunction tokenComment(stream, state) {\n  var prev, next;\n  while ((next = stream.next()) != null) {\n    if (prev === '*' && next === '/') {\n      state.tokenize = tokenBase;\n      break;\n    }\n    prev = next;\n  }\n  return 'comment';\n}\nfunction currentScope(state) {\n  var scope = null;\n  if (state.scopes.length > 0) scope = state.scopes[state.scopes.length - 1];\n  return scope;\n}\nexport var yacas = {\n  name: \"yacas\",\n  startState: function startState() {\n    return {\n      tokenize: tokenBase,\n      scopes: []\n    };\n  },\n  token: function token(stream, state) {\n    if (stream.eatSpace()) return null;\n    return state.tokenize(stream, state);\n  },\n  indent: function indent(state, textAfter, cx) {\n    if (state.tokenize !== tokenBase && state.tokenize !== null) return null;\n    var delta = 0;\n    if (textAfter === ']' || textAfter === '];' || textAfter === '}' || textAfter === '};' || textAfter === ');') delta = -1;\n    return (state.scopes.length + delta) * cx.unit;\n  },\n  languageData: {\n    electricInput: /[{}\\[\\]()\\;]/,\n    commentTokens: {\n      line: \"//\",\n      block: {\n        open: \"/*\",\n        close: \"*/\"\n      }\n    }\n  }\n};"],"sourceRoot":""}