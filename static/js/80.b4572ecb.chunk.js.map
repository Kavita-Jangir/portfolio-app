{"version":3,"sources":["D:/react_app/app_1/node_modules/@codemirror/legacy-modes/mode/sass.js"],"names":["__webpack_require__","r","__webpack_exports__","d","sass","_css_js__WEBPACK_IMPORTED_MODULE_0__","propertyKeywords","Set","properties","colorKeywords","colors","valueKeywords","values","fontProperties","fonts","word","keywordsRegexp","RegExp","join","opRegexp","pseudoElementsRegexp","isEndLine","stream","peek","match","urlTokens","state","ch","next","tokenizer","tokenBase","eatSpace","buildStringTokenizer","comment","indentation","multiLine","sol","skipTo","skipToEnd","quote","greedy","stringTokenizer","nextChar","peekChar","previousChar","string","charAt","pos","cursorHalf","buildInterpolationTokenizer","currentTokenizer","indent","indentCount","currentOffset","scopes","offset","indentUnit","unshift","dedent","length","shift","eatWhile","current","toLowerCase","has","prevProp","prop","name","startState","type","definedVars","definedMixins","token","style","withCurrentIndent","newScopes","i","scope","push","tokenLexer","lastToken","content","languageData","commentTokens","line","block","open","close","autocomplete","all"],"mappings":"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","file":"static/js/80.b4572ecb.chunk.js","sourcesContent":["import { keywords as cssKeywords } from \"./css.js\";\nvar propertyKeywords = new Set(cssKeywords.properties);\nvar colorKeywords = new Set(cssKeywords.colors);\nvar valueKeywords = new Set(cssKeywords.values);\nvar fontProperties = new Set(cssKeywords.fonts);\nfunction tokenRegexp(words) {\n  return new RegExp(\"^\" + words.join(\"|\"));\n}\nvar keywords = [\"true\", \"false\", \"null\", \"auto\"];\nvar keywordsRegexp = new RegExp(\"^\" + keywords.join(\"|\"));\nvar operators = [\"\\\\(\", \"\\\\)\", \"=\", \">\", \"<\", \"==\", \">=\", \"<=\", \"\\\\+\", \"-\", \"\\\\!=\", \"/\", \"\\\\*\", \"%\", \"and\", \"or\", \"not\", \";\", \"\\\\{\", \"\\\\}\", \":\"];\nvar opRegexp = tokenRegexp(operators);\nvar pseudoElementsRegexp = /^::?[a-zA-Z_][\\w\\-]*/;\nvar word;\nfunction isEndLine(stream) {\n  return !stream.peek() || stream.match(/\\s+$/, false);\n}\nfunction urlTokens(stream, state) {\n  var ch = stream.peek();\n  if (ch === \")\") {\n    stream.next();\n    state.tokenizer = tokenBase;\n    return \"operator\";\n  } else if (ch === \"(\") {\n    stream.next();\n    stream.eatSpace();\n    return \"operator\";\n  } else if (ch === \"'\" || ch === '\"') {\n    state.tokenizer = buildStringTokenizer(stream.next());\n    return \"string\";\n  } else {\n    state.tokenizer = buildStringTokenizer(\")\", false);\n    return \"string\";\n  }\n}\nfunction comment(indentation, multiLine) {\n  return function (stream, state) {\n    if (stream.sol() && stream.indentation() <= indentation) {\n      state.tokenizer = tokenBase;\n      return tokenBase(stream, state);\n    }\n    if (multiLine && stream.skipTo(\"*/\")) {\n      stream.next();\n      stream.next();\n      state.tokenizer = tokenBase;\n    } else {\n      stream.skipToEnd();\n    }\n    return \"comment\";\n  };\n}\nfunction buildStringTokenizer(quote, greedy) {\n  if (greedy == null) {\n    greedy = true;\n  }\n  function stringTokenizer(stream, state) {\n    var nextChar = stream.next();\n    var peekChar = stream.peek();\n    var previousChar = stream.string.charAt(stream.pos - 2);\n    var endingString = nextChar !== \"\\\\\" && peekChar === quote || nextChar === quote && previousChar !== \"\\\\\";\n    if (endingString) {\n      if (nextChar !== quote && greedy) {\n        stream.next();\n      }\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0;\n      }\n      state.tokenizer = tokenBase;\n      return \"string\";\n    } else if (nextChar === \"#\" && peekChar === \"{\") {\n      state.tokenizer = buildInterpolationTokenizer(stringTokenizer);\n      stream.next();\n      return \"operator\";\n    } else {\n      return \"string\";\n    }\n  }\n  return stringTokenizer;\n}\nfunction buildInterpolationTokenizer(currentTokenizer) {\n  return function (stream, state) {\n    if (stream.peek() === \"}\") {\n      stream.next();\n      state.tokenizer = currentTokenizer;\n      return \"operator\";\n    } else {\n      return tokenBase(stream, state);\n    }\n  };\n}\nfunction indent(state, stream) {\n  if (state.indentCount == 0) {\n    state.indentCount++;\n    var lastScopeOffset = state.scopes[0].offset;\n    var currentOffset = lastScopeOffset + stream.indentUnit;\n    state.scopes.unshift({\n      offset: currentOffset\n    });\n  }\n}\nfunction dedent(state) {\n  if (state.scopes.length == 1) return;\n  state.scopes.shift();\n}\nfunction tokenBase(stream, state) {\n  var ch = stream.peek();\n\n  // Comment\n  if (stream.match(\"/*\")) {\n    state.tokenizer = comment(stream.indentation(), true);\n    return state.tokenizer(stream, state);\n  }\n  if (stream.match(\"//\")) {\n    state.tokenizer = comment(stream.indentation(), false);\n    return state.tokenizer(stream, state);\n  }\n\n  // Interpolation\n  if (stream.match(\"#{\")) {\n    state.tokenizer = buildInterpolationTokenizer(tokenBase);\n    return \"operator\";\n  }\n\n  // Strings\n  if (ch === '\"' || ch === \"'\") {\n    stream.next();\n    state.tokenizer = buildStringTokenizer(ch);\n    return \"string\";\n  }\n  if (!state.cursorHalf) {\n    // first half i.e. before : for key-value pairs\n    // including selectors\n    if (ch === \"-\") {\n      if (stream.match(/^-\\w+-/)) {\n        return \"meta\";\n      }\n    }\n    if (ch === \".\") {\n      stream.next();\n      if (stream.match(/^[\\w-]+/)) {\n        indent(state, stream);\n        return \"qualifier\";\n      } else if (stream.peek() === \"#\") {\n        indent(state, stream);\n        return \"tag\";\n      }\n    }\n    if (ch === \"#\") {\n      stream.next();\n      // ID selectors\n      if (stream.match(/^[\\w-]+/)) {\n        indent(state, stream);\n        return \"builtin\";\n      }\n      if (stream.peek() === \"#\") {\n        indent(state, stream);\n        return \"tag\";\n      }\n    }\n\n    // Variables\n    if (ch === \"$\") {\n      stream.next();\n      stream.eatWhile(/[\\w-]/);\n      return \"variable-2\";\n    }\n\n    // Numbers\n    if (stream.match(/^-?[0-9\\.]+/)) return \"number\";\n\n    // Units\n    if (stream.match(/^(px|em|in)\\b/)) return \"unit\";\n    if (stream.match(keywordsRegexp)) return \"keyword\";\n    if (stream.match(/^url/) && stream.peek() === \"(\") {\n      state.tokenizer = urlTokens;\n      return \"atom\";\n    }\n    if (ch === \"=\") {\n      // Match shortcut mixin definition\n      if (stream.match(/^=[\\w-]+/)) {\n        indent(state, stream);\n        return \"meta\";\n      }\n    }\n    if (ch === \"+\") {\n      // Match shortcut mixin definition\n      if (stream.match(/^\\+[\\w-]+/)) {\n        return \"meta\";\n      }\n    }\n    if (ch === \"@\") {\n      if (stream.match('@extend')) {\n        if (!stream.match(/\\s*[\\w]/)) dedent(state);\n      }\n    }\n\n    // Indent Directives\n    if (stream.match(/^@(else if|if|media|else|for|each|while|mixin|function)/)) {\n      indent(state, stream);\n      return \"def\";\n    }\n\n    // Other Directives\n    if (ch === \"@\") {\n      stream.next();\n      stream.eatWhile(/[\\w-]/);\n      return \"def\";\n    }\n    if (stream.eatWhile(/[\\w-]/)) {\n      if (stream.match(/ *: *[\\w-\\+\\$#!\\(\"']/, false)) {\n        word = stream.current().toLowerCase();\n        var prop = state.prevProp + \"-\" + word;\n        if (propertyKeywords.has(prop)) {\n          return \"property\";\n        } else if (propertyKeywords.has(word)) {\n          state.prevProp = word;\n          return \"property\";\n        } else if (fontProperties.has(word)) {\n          return \"property\";\n        }\n        return \"tag\";\n      } else if (stream.match(/ *:/, false)) {\n        indent(state, stream);\n        state.cursorHalf = 1;\n        state.prevProp = stream.current().toLowerCase();\n        return \"property\";\n      } else if (stream.match(/ *,/, false)) {\n        return \"tag\";\n      } else {\n        indent(state, stream);\n        return \"tag\";\n      }\n    }\n    if (ch === \":\") {\n      if (stream.match(pseudoElementsRegexp)) {\n        // could be a pseudo-element\n        return \"type\";\n      }\n      stream.next();\n      state.cursorHalf = 1;\n      return \"operator\";\n    }\n  } else {\n    if (ch === \"#\") {\n      stream.next();\n      // Hex numbers\n      if (stream.match(/[0-9a-fA-F]{6}|[0-9a-fA-F]{3}/)) {\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"number\";\n      }\n    }\n\n    // Numbers\n    if (stream.match(/^-?[0-9\\.]+/)) {\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0;\n      }\n      return \"number\";\n    }\n\n    // Units\n    if (stream.match(/^(px|em|in)\\b/)) {\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0;\n      }\n      return \"unit\";\n    }\n    if (stream.match(keywordsRegexp)) {\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0;\n      }\n      return \"keyword\";\n    }\n    if (stream.match(/^url/) && stream.peek() === \"(\") {\n      state.tokenizer = urlTokens;\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0;\n      }\n      return \"atom\";\n    }\n\n    // Variables\n    if (ch === \"$\") {\n      stream.next();\n      stream.eatWhile(/[\\w-]/);\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0;\n      }\n      return \"variable-2\";\n    }\n\n    // bang character for !important, !default, etc.\n    if (ch === \"!\") {\n      stream.next();\n      state.cursorHalf = 0;\n      return stream.match(/^[\\w]+/) ? \"keyword\" : \"operator\";\n    }\n    if (stream.match(opRegexp)) {\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0;\n      }\n      return \"operator\";\n    }\n\n    // attributes\n    if (stream.eatWhile(/[\\w-]/)) {\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0;\n      }\n      word = stream.current().toLowerCase();\n      if (valueKeywords.has(word)) {\n        return \"atom\";\n      } else if (colorKeywords.has(word)) {\n        return \"keyword\";\n      } else if (propertyKeywords.has(word)) {\n        state.prevProp = stream.current().toLowerCase();\n        return \"property\";\n      } else {\n        return \"tag\";\n      }\n    }\n    if (isEndLine(stream)) {\n      state.cursorHalf = 0;\n      return null;\n    }\n  }\n  if (stream.match(opRegexp)) return \"operator\";\n  stream.next();\n  return null;\n}\nfunction tokenLexer(stream, state) {\n  if (stream.sol()) state.indentCount = 0;\n  var style = state.tokenizer(stream, state);\n  var current = stream.current();\n  if (current === \"@return\" || current === \"}\") {\n    dedent(state);\n  }\n  if (style !== null) {\n    var startOfToken = stream.pos - current.length;\n    var withCurrentIndent = startOfToken + stream.indentUnit * state.indentCount;\n    var newScopes = [];\n    for (var i = 0; i < state.scopes.length; i++) {\n      var scope = state.scopes[i];\n      if (scope.offset <= withCurrentIndent) newScopes.push(scope);\n    }\n    state.scopes = newScopes;\n  }\n  return style;\n}\nexport var sass = {\n  name: \"sass\",\n  startState: function startState() {\n    return {\n      tokenizer: tokenBase,\n      scopes: [{\n        offset: 0,\n        type: \"sass\"\n      }],\n      indentCount: 0,\n      cursorHalf: 0,\n      // cursor half tells us if cursor lies after (1)\n      // or before (0) colon (well... more or less)\n      definedVars: [],\n      definedMixins: []\n    };\n  },\n  token: function token(stream, state) {\n    var style = tokenLexer(stream, state);\n    state.lastToken = {\n      style: style,\n      content: stream.current()\n    };\n    return style;\n  },\n  indent: function indent(state) {\n    return state.scopes[0].offset;\n  },\n  languageData: {\n    commentTokens: {\n      line: \"//\",\n      block: {\n        open: \"/*\",\n        close: \"*/\"\n      }\n    },\n    autocomplete: cssKeywords.all\n  }\n};"],"sourceRoot":""}