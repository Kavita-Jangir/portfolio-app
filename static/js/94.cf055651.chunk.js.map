{"version":3,"sources":["D:/react_app/app_1/node_modules/@codemirror/legacy-modes/mode/tiki.js"],"names":["inBlock","style","terminator","returnTokenizer","stream","state","eol","match","tokenize","inText","next","inLine","chain","parser","sol","ch","eat","eatSpace","eatWhile","inPlugin","pluginName","type","curState","setStyle","quote","peek","test","pass","i","arguments","length","cc","push","cont","apply","pushContext","startOfLine","noIndent","context","prev","indent","indented","popContext","element","attributes","err","endcloseplugin","name","attvalue","attvaluemaybe","__webpack_require__","r","__webpack_exports__","d","tiki","startState","token","indentation","pop","textAfter","cx","unit"],"mappings":"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","file":"static/js/94.cf055651.chunk.js","sourcesContent":["function inBlock(style, terminator, returnTokenizer) {\n  return function (stream, state) {\n    while (!stream.eol()) {\n      if (stream.match(terminator)) {\n        state.tokenize = inText;\n        break;\n      }\n      stream.next();\n    }\n    if (returnTokenizer) state.tokenize = returnTokenizer;\n    return style;\n  };\n}\nfunction inLine(style) {\n  return function (stream, state) {\n    while (!stream.eol()) {\n      stream.next();\n    }\n    state.tokenize = inText;\n    return style;\n  };\n}\nfunction inText(stream, state) {\n  function chain(parser) {\n    state.tokenize = parser;\n    return parser(stream, state);\n  }\n  var sol = stream.sol();\n  var ch = stream.next();\n\n  //non start of line\n  switch (ch) {\n    //switch is generally much faster than if, so it is used here\n    case \"{\":\n      //plugin\n      stream.eat(\"/\");\n      stream.eatSpace();\n      stream.eatWhile(/[^\\s\\u00a0=\\\"\\'\\/?(}]/);\n      state.tokenize = inPlugin;\n      return \"tag\";\n    case \"_\":\n      //bold\n      if (stream.eat(\"_\")) return chain(inBlock(\"strong\", \"__\", inText));\n      break;\n    case \"'\":\n      //italics\n      if (stream.eat(\"'\")) return chain(inBlock(\"em\", \"''\", inText));\n      break;\n    case \"(\":\n      // Wiki Link\n      if (stream.eat(\"(\")) return chain(inBlock(\"link\", \"))\", inText));\n      break;\n    case \"[\":\n      // Weblink\n      return chain(inBlock(\"url\", \"]\", inText));\n      break;\n    case \"|\":\n      //table\n      if (stream.eat(\"|\")) return chain(inBlock(\"comment\", \"||\"));\n      break;\n    case \"-\":\n      if (stream.eat(\"=\")) {\n        //titleBar\n        return chain(inBlock(\"header string\", \"=-\", inText));\n      } else if (stream.eat(\"-\")) {\n        //deleted\n        return chain(inBlock(\"error tw-deleted\", \"--\", inText));\n      }\n      break;\n    case \"=\":\n      //underline\n      if (stream.match(\"==\")) return chain(inBlock(\"tw-underline\", \"===\", inText));\n      break;\n    case \":\":\n      if (stream.eat(\":\")) return chain(inBlock(\"comment\", \"::\"));\n      break;\n    case \"^\":\n      //box\n      return chain(inBlock(\"tw-box\", \"^\"));\n      break;\n    case \"~\":\n      //np\n      if (stream.match(\"np~\")) return chain(inBlock(\"meta\", \"~/np~\"));\n      break;\n  }\n\n  //start of line types\n  if (sol) {\n    switch (ch) {\n      case \"!\":\n        //header at start of line\n        if (stream.match('!!!!!')) {\n          return chain(inLine(\"header string\"));\n        } else if (stream.match('!!!!')) {\n          return chain(inLine(\"header string\"));\n        } else if (stream.match('!!!')) {\n          return chain(inLine(\"header string\"));\n        } else if (stream.match('!!')) {\n          return chain(inLine(\"header string\"));\n        } else {\n          return chain(inLine(\"header string\"));\n        }\n        break;\n      case \"*\": //unordered list line item, or <li /> at start of line\n      case \"#\": //ordered list line item, or <li /> at start of line\n      case \"+\":\n        //ordered list line item, or <li /> at start of line\n        return chain(inLine(\"tw-listitem bracket\"));\n        break;\n    }\n  }\n\n  //stream.eatWhile(/[&{]/); was eating up plugins, turned off to act less like html and more like tiki\n  return null;\n}\n\n// Return variables for tokenizers\nvar pluginName, type;\nfunction inPlugin(stream, state) {\n  var ch = stream.next();\n  var peek = stream.peek();\n  if (ch == \"}\") {\n    state.tokenize = inText;\n    //type = ch == \")\" ? \"endPlugin\" : \"selfclosePlugin\"; inPlugin\n    return \"tag\";\n  } else if (ch == \"(\" || ch == \")\") {\n    return \"bracket\";\n  } else if (ch == \"=\") {\n    type = \"equals\";\n    if (peek == \">\") {\n      stream.next();\n      peek = stream.peek();\n    }\n\n    //here we detect values directly after equal character with no quotes\n    if (!/[\\'\\\"]/.test(peek)) {\n      state.tokenize = inAttributeNoQuote();\n    }\n    //end detect values\n\n    return \"operator\";\n  } else if (/[\\'\\\"]/.test(ch)) {\n    state.tokenize = inAttribute(ch);\n    return state.tokenize(stream, state);\n  } else {\n    stream.eatWhile(/[^\\s\\u00a0=\\\"\\'\\/?]/);\n    return \"keyword\";\n  }\n}\nfunction inAttribute(quote) {\n  return function (stream, state) {\n    while (!stream.eol()) {\n      if (stream.next() == quote) {\n        state.tokenize = inPlugin;\n        break;\n      }\n    }\n    return \"string\";\n  };\n}\nfunction inAttributeNoQuote() {\n  return function (stream, state) {\n    while (!stream.eol()) {\n      var ch = stream.next();\n      var peek = stream.peek();\n      if (ch == \" \" || ch == \",\" || /[ )}]/.test(peek)) {\n        state.tokenize = inPlugin;\n        break;\n      }\n    }\n    return \"string\";\n  };\n}\nvar curState, setStyle;\nfunction pass() {\n  for (var i = arguments.length - 1; i >= 0; i--) curState.cc.push(arguments[i]);\n}\nfunction cont() {\n  pass.apply(null, arguments);\n  return true;\n}\nfunction pushContext(pluginName, startOfLine) {\n  var noIndent = curState.context && curState.context.noIndent;\n  curState.context = {\n    prev: curState.context,\n    pluginName: pluginName,\n    indent: curState.indented,\n    startOfLine: startOfLine,\n    noIndent: noIndent\n  };\n}\nfunction popContext() {\n  if (curState.context) curState.context = curState.context.prev;\n}\nfunction element(type) {\n  if (type == \"openPlugin\") {\n    curState.pluginName = pluginName;\n    return cont(attributes, endplugin(curState.startOfLine));\n  } else if (type == \"closePlugin\") {\n    var err = false;\n    if (curState.context) {\n      err = curState.context.pluginName != pluginName;\n      popContext();\n    } else {\n      err = true;\n    }\n    if (err) setStyle = \"error\";\n    return cont(endcloseplugin(err));\n  } else if (type == \"string\") {\n    if (!curState.context || curState.context.name != \"!cdata\") pushContext(\"!cdata\");\n    if (curState.tokenize == inText) popContext();\n    return cont();\n  } else return cont();\n}\nfunction endplugin(startOfLine) {\n  return function (type) {\n    if (type == \"selfclosePlugin\" || type == \"endPlugin\") return cont();\n    if (type == \"endPlugin\") {\n      pushContext(curState.pluginName, startOfLine);\n      return cont();\n    }\n    return cont();\n  };\n}\nfunction endcloseplugin(err) {\n  return function (type) {\n    if (err) setStyle = \"error\";\n    if (type == \"endPlugin\") return cont();\n    return pass();\n  };\n}\nfunction attributes(type) {\n  if (type == \"keyword\") {\n    setStyle = \"attribute\";\n    return cont(attributes);\n  }\n  if (type == \"equals\") return cont(attvalue, attributes);\n  return pass();\n}\nfunction attvalue(type) {\n  if (type == \"keyword\") {\n    setStyle = \"string\";\n    return cont();\n  }\n  if (type == \"string\") return cont(attvaluemaybe);\n  return pass();\n}\nfunction attvaluemaybe(type) {\n  if (type == \"string\") return cont(attvaluemaybe);else return pass();\n}\nexport var tiki = {\n  name: \"tiki\",\n  startState: function startState() {\n    return {\n      tokenize: inText,\n      cc: [],\n      indented: 0,\n      startOfLine: true,\n      pluginName: null,\n      context: null\n    };\n  },\n  token: function token(stream, state) {\n    if (stream.sol()) {\n      state.startOfLine = true;\n      state.indented = stream.indentation();\n    }\n    if (stream.eatSpace()) return null;\n    setStyle = type = pluginName = null;\n    var style = state.tokenize(stream, state);\n    if ((style || type) && style != \"comment\") {\n      curState = state;\n      while (true) {\n        var comb = state.cc.pop() || element;\n        if (comb(type || style)) break;\n      }\n    }\n    state.startOfLine = false;\n    return setStyle || style;\n  },\n  indent: function indent(state, textAfter, cx) {\n    var context = state.context;\n    if (context && context.noIndent) return 0;\n    if (context && /^{\\//.test(textAfter)) context = context.prev;\n    while (context && !context.startOfLine) context = context.prev;\n    if (context) return context.indent + cx.unit;else return 0;\n  }\n};"],"sourceRoot":""}