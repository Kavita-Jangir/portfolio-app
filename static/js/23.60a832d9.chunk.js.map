{"version":3,"sources":["D:/react_app/app_1/node_modules/@lezer/xml/dist/index.es.js","D:/react_app/app_1/node_modules/@codemirror/lang-xml/dist/index.js"],"names":["nameChar","ch","cachedName","cachedInput","cachedPos","tagNameAfter","input","offset","pos","peek","name","next","String","fromCharCode","ElementContext","parent","this","hash","i","length","charCodeAt","elementContext","dist","start","shift","context","term","stack","reduce","reuse","node","_stack","type","id","strict","startTag","advance","acceptToken","cx","contextual","scanTo","end","endPos","len","commentContent","piContent","cdataContent","xmlHighlighting","Object","highlight_dist","Text","content","StartTag StartCloseTag EndTag SelfCloseEndTag","angleBracket","TagName","tagName","MismatchedCloseTag/Tagname","invalid","AttributeName","attributeName","AttributeValue","attributeValue","Is","definitionOperator","EntityReference CharacterReference","character","Comment","blockComment","ProcessingInst","processingInstruction","DoctypeDecl","documentMeta","Cdata","special","string","parser","deserialize","version","states","stateData","goto","nodeNames","maxTerm","nodeProps","propSources","skippedNodes","repeatNodeCount","tokenData","tokenizers","topRules","Document","tokenPrec","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","minLen","_arrayLikeToArray","n","prototype","toString","call","slice","constructor","from","test","_unsupportedIterableToArray","F","s","done","value","e","_e","f","TypeError","err","normalCompletion","didErr","step","_e2","return","arr","arr2","doc","tag","getChild","sliceString","to","elementName","tree","firstChild","findParentElement","cur","__webpack_require__","d","__webpack_exports__","completeFromSchema","xml","xmlLanguage","dist_Element","Element","spec","attrs","attrValues","classCallCheck","children","completion","assign","label","openCompletion","closeCompletion","boost","closeNameCompletion","text","textContent","map","Identifier","attrCompletion","valueCompletion","concat","eltSpecs","attrSpecs","_step","allAttrs","globalAttrs","create","_iterator","_s","push","global","values","_step2","allElements","topElements","byName","_iterator2","_loop","attrVals","attributes","find","a","elt","top","_step3","_iterator3","_a","state","loc","at","language_dist","resolveInner","inTag","lastChild","isError","before","childBefore","findLocation","explicit","parentName","options","validFor","_parentName","_parent","attr","getChildren","attrName","_parent2","_parentName2","_parent3","closing","last","openTag","sliceDoc","define","configure","props","add","closed","textAfter","lineIndent","unit","OpenTag CloseTag SelfClosingTag","column","subtree","first","OpenTag CloseTag","languageData","commentTokens","block","open","close","indentOnInput","conf","arguments","undefined","data","of","autocomplete","elements"],"mappings":"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","file":"static/js/23.60a832d9.chunk.js","sourcesContent":["import { ContextTracker, ExternalTokenizer, LRParser } from '@lezer/lr';\nimport { styleTags, tags } from '@lezer/highlight';\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nvar StartTag = 1,\n  StartCloseTag = 2,\n  MissingCloseTag = 3,\n  mismatchedStartCloseTag = 4,\n  incompleteStartCloseTag = 5,\n  commentContent$1 = 35,\n  piContent$1 = 36,\n  cdataContent$1 = 37,\n  Element = 11,\n  OpenTag = 13;\n\n/* Hand-written tokenizer for XML tag matching. */\n\nfunction nameChar(ch) {\n  return ch == 45 || ch == 46 || ch == 58 || ch >= 65 && ch <= 90 || ch == 95 || ch >= 97 && ch <= 122 || ch >= 161;\n}\nfunction isSpace(ch) {\n  return ch == 9 || ch == 10 || ch == 13 || ch == 32;\n}\nvar cachedName = null,\n  cachedInput = null,\n  cachedPos = 0;\nfunction tagNameAfter(input, offset) {\n  var pos = input.pos + offset;\n  if (cachedInput == input && cachedPos == pos) return cachedName;\n  while (isSpace(input.peek(offset))) offset++;\n  var name = \"\";\n  for (;;) {\n    var next = input.peek(offset);\n    if (!nameChar(next)) break;\n    name += String.fromCharCode(next);\n    offset++;\n  }\n  cachedInput = input;\n  cachedPos = pos;\n  return cachedName = name || null;\n}\nfunction ElementContext(name, parent) {\n  this.name = name;\n  this.parent = parent;\n  this.hash = parent ? parent.hash : 0;\n  for (var i = 0; i < name.length; i++) this.hash += (this.hash << 4) + name.charCodeAt(i) + (name.charCodeAt(i) << 8);\n}\nvar elementContext = new ContextTracker({\n  start: null,\n  shift: function shift(context, term, stack, input) {\n    return term == StartTag ? new ElementContext(tagNameAfter(input, 1) || \"\", context) : context;\n  },\n  reduce: function reduce(context, term) {\n    return term == Element && context ? context.parent : context;\n  },\n  reuse: function reuse(context, node, _stack, input) {\n    var type = node.type.id;\n    return type == StartTag || type == OpenTag ? new ElementContext(tagNameAfter(input, 1) || \"\", context) : context;\n  },\n  hash: function hash(context) {\n    return context ? context.hash : 0;\n  },\n  strict: false\n});\nvar startTag = new ExternalTokenizer(function (input, stack) {\n  if (input.next != 60 /* '<' */) return;\n  input.advance();\n  if (input.next == 47 /* '/' */) {\n    input.advance();\n    var name = tagNameAfter(input, 0);\n    if (!name) return input.acceptToken(incompleteStartCloseTag);\n    if (stack.context && name == stack.context.name) return input.acceptToken(StartCloseTag);\n    for (var cx = stack.context; cx; cx = cx.parent) if (cx.name == name) return input.acceptToken(MissingCloseTag, -2);\n    input.acceptToken(mismatchedStartCloseTag);\n  } else if (input.next != 33 /* '!' */ && input.next != 63 /* '?' */) {\n    return input.acceptToken(StartTag);\n  }\n}, {\n  contextual: true\n});\nfunction scanTo(type, end) {\n  return new ExternalTokenizer(function (input) {\n    for (var endPos = 0, len = 0;; len++) {\n      if (input.next < 0) {\n        if (len) input.acceptToken(type);\n        break;\n      }\n      if (input.next == end.charCodeAt(endPos)) {\n        endPos++;\n        if (endPos == end.length) {\n          if (len >= end.length) input.acceptToken(type, 1 - end.length);\n          break;\n        }\n      } else {\n        endPos = input.next == end.charCodeAt(0) ? 1 : 0;\n      }\n      input.advance();\n    }\n  });\n}\nvar commentContent = scanTo(commentContent$1, \"-->\");\nvar piContent = scanTo(piContent$1, \"?>\");\nvar cdataContent = scanTo(cdataContent$1, \"]]>\");\nvar xmlHighlighting = styleTags({\n  Text: tags.content,\n  \"StartTag StartCloseTag EndTag SelfCloseEndTag\": tags.angleBracket,\n  TagName: tags.tagName,\n  \"MismatchedCloseTag/Tagname\": [tags.tagName, tags.invalid],\n  AttributeName: tags.attributeName,\n  AttributeValue: tags.attributeValue,\n  Is: tags.definitionOperator,\n  \"EntityReference CharacterReference\": tags.character,\n  Comment: tags.blockComment,\n  ProcessingInst: tags.processingInstruction,\n  DoctypeDecl: tags.documentMeta,\n  Cdata: tags.special(tags.string)\n});\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nvar parser = LRParser.deserialize({\n  version: 14,\n  states: \",SOQOaOOOrOxO'#CfOzOpO'#CiO!tOaO'#CgOOOP'#Cg'#CgO!{OrO'#CrO#TOtO'#CsO#]OpO'#CtOOOP'#DS'#DSOOOP'#Cv'#CvQQOaOOOOOW'#Cw'#CwO#eOxO,59QOOOP,59Q,59QOOOO'#Cx'#CxO#mOpO,59TO#uO!bO,59TOOOP'#C{'#C{O$TOaO,59RO$[OpO'#CoOOOP,59R,59ROOOQ'#C|'#C|O$dOrO,59^OOOP,59^,59^OOOS'#C}'#C}O$lOtO,59_OOOP,59_,59_O$tOpO,59`O$|OpO,59`OOOP-E6t-E6tOOOW-E6u-E6uOOOP1G.l1G.lOOOO-E6v-E6vO%UO!bO1G.oO%UO!bO1G.oO%dOpO'#CkO%lO!bO'#CyO%zO!bO1G.oOOOP1G.o1G.oOOOP1G.w1G.wOOOP-E6y-E6yOOOP1G.m1G.mO&VOpO,59ZO&_OpO,59ZOOOQ-E6z-E6zOOOP1G.x1G.xOOOS-E6{-E6{OOOP1G.y1G.yO&gOpO1G.zO&gOpO1G.zOOOP1G.z1G.zO&oO!bO7+$ZO&}O!bO7+$ZOOOP7+$Z7+$ZOOOP7+$c7+$cO'YOpO,59VO'bOpO,59VO'jO!bO,59eOOOO-E6w-E6wO'xOpO1G.uO'xOpO1G.uOOOP1G.u1G.uO(QOpO7+$fOOOP7+$f7+$fO(YO!bO<<GuOOOP<<Gu<<GuOOOP<<G}<<G}O'bOpO1G.qO'bOpO1G.qO(eO#tO'#CnOOOO1G.q1G.qO(sOpO7+$aOOOP7+$a7+$aOOOP<<HQ<<HQOOOPAN=aAN=aOOOPAN=iAN=iO'bOpO7+$]OOOO7+$]7+$]OOOO'#Cz'#CzO({O#tO,59YOOOO,59Y,59YOOOP<<G{<<G{OOOO<<Gw<<GwOOOO-E6x-E6xOOOO1G.t1G.t\",\n  stateData: \")Z~OPQOSVOTWOVWOWWOXWOiXOxPO}TO!PUO~OuZOw]O~O^`Oy^O~OPQOQcOSVOTWOVWOWWOXWOxPO}TO!PUO~ORdO~P!SOseO|gO~OthO!OjO~O^lOy^O~OuZOwoO~O^qOy^O~O[vO`sOdwOy^O~ORyO~P!SO^{Oy^O~OseO|}O~OthO!O!PO~O^!QOy^O~O[!SOy^O~O[!VO`sOd!WOy^O~Oa!YOy^O~Oy^O[mX`mXdmX~O[!VO`sOd!WO~O^!]Oy^O~O[!_Oy^O~O[!aOy^O~O[!cO`sOd!dOy^O~O[!cO`sOd!dO~Oa!eOy^O~Oy^Oz!gO~Oy^O[ma`madma~O[!jOy^O~O[!kOy^O~O[!lO`sOd!mO~OW!pOX!pOz!rO{!pO~O[!sOy^O~OW!pOX!pOz!vO{!pO~O\",\n  goto: \"%[wPPPPPPPPPPxxP!OP!UPP!_!iP!oxxxP!u!{#R$Z$j$p$v$|PPPP%SXWORYbXRORYb_t`qru!T!U!bQ!h!YS!o!e!fR!t!nQdRRybXSORYbQYORmYQ[PRn[Q_QQkVjp_krz!R!T!X!Z!^!`!f!i!nQr`QzcQ!RlQ!TqQ!XsQ!ZtQ!^{Q!`!QQ!f!YQ!i!]R!n!eQu`S!UqrU![u!U!bR!b!TQ!q!gR!u!qQbRRxbQfTR|fQiUR!OiSXOYTaRb\",\n  nodeNames: \"âš  StartTag StartCloseTag MissingCloseTag StartCloseTag StartCloseTag Document Text EntityReference CharacterReference Cdata Element EndTag OpenTag TagName Attribute AttributeName Is AttributeValue CloseTag SelfCloseEndTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag DoctypeDecl\",\n  maxTerm: 47,\n  context: elementContext,\n  nodeProps: [[\"closedBy\", 1, \"SelfCloseEndTag EndTag\", 13, \"CloseTag MissingCloseTag\"], [\"openedBy\", 12, \"StartTag StartCloseTag\", 19, \"OpenTag\", 20, \"StartTag\"]],\n  propSources: [xmlHighlighting],\n  skippedNodes: [0],\n  repeatNodeCount: 8,\n  tokenData: \"IX~R!XOX$nXY&kYZ&kZ]$n]^&k^p$npq&kqr$nrs'ssv$nvw(Zw}$n}!O*l!O!P$n!P!Q,{!Q![$n![!].e!]!^$n!^!_1v!_!`Cz!`!aDm!a!bE`!b!c$n!c!}.e!}#P$n#P#QFx#Q#R$n#R#S.e#S#T$n#T#o.e#o%W$n%W%o.e%o%p$n%p&a.e&a&b$n&b1p.e1p4U$n4U4d.e4d4e$n4e$IS.e$IS$I`$n$I`$Ib.e$Ib$Kh$n$Kh%#t.e%#t&/x$n&/x&Et.e&Et&FV$n&FV;'S.e;'S;:j1p;:j;=`&e<%l?&r$n?&r?Ah.e?Ah?BY$n?BY?Mn.e?MnO$nX$uWVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nP%dTVPOv%_w!^%_!_;'S%_;'S;=`%s<%lO%_P%vP;=`<%l%_W&OT{WOr%ysv%yw;'S%y;'S;=`&_<%lO%yW&bP;=`<%l%yX&hP;=`<%l$n_&t_VP{WyUOX$nXY&kYZ&kZ]$n]^&k^p$npq&kqr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nZ'zTzYVPOv%_w!^%_!_;'S%_;'S;=`%s<%lO%_~(^VOp(sqs(sst)ht!](s!^;'S(s;'S;=`)b<%lO(s~(vVOp(sqs(st!](s!]!^)]!^;'S(s;'S;=`)b<%lO(s~)bOW~~)eP;=`<%l(s~)kTOp)zq!])z!^;'S)z;'S;=`*f<%lO)z~)}UOp)zq!])z!]!^*a!^;'S)z;'S;=`*f<%lO)z~*fOX~~*iP;=`<%l)zZ*sYVP{WOr$nrs%_sv$nw}$n}!O+c!O!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nZ+jYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_!`$n!`!a,Y!a;'S$n;'S;=`&e<%lO$nZ,cW|QVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$n]-SYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_!`$n!`!a-r!a;'S$n;'S;=`&e<%lO$n]-{WdSVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$n_.p!O`S^QVP{WOr$nrs%_sv$nw}$n}!O.e!O!P.e!P!Q$n!Q![.e![!].e!]!^$n!^!_%y!_!c$n!c!}.e!}#R$n#R#S.e#S#T$n#T#o.e#o$}$n$}%O.e%O%W$n%W%o.e%o%p$n%p&a.e&a&b$n&b1p.e1p4U.e4U4d.e4d4e$n4e$IS.e$IS$I`$n$I`$Ib.e$Ib$Je$n$Je$Jg.e$Jg$Kh$n$Kh%#t.e%#t&/x$n&/x&Et.e&Et&FV$n&FV;'S.e;'S;:j1p;:j;=`&e<%l?&r$n?&r?Ah.e?Ah?BY$n?BY?Mn.e?MnO$n_1sP;=`<%l.eX1{W{WOq%yqr2esv%yw!a%y!a!bCd!b;'S%y;'S;=`&_<%lO%yX2j]{WOr%ysv%yw}%y}!O3c!O!f%y!f!g4e!g!}%y!}#O9t#O#W%y#W#X@Q#X;'S%y;'S;=`&_<%lO%yX3hV{WOr%ysv%yw}%y}!O3}!O;'S%y;'S;=`&_<%lO%yX4UT}P{WOr%ysv%yw;'S%y;'S;=`&_<%lO%yX4jV{WOr%ysv%yw!q%y!q!r5P!r;'S%y;'S;=`&_<%lO%yX5UV{WOr%ysv%yw!e%y!e!f5k!f;'S%y;'S;=`&_<%lO%yX5pV{WOr%ysv%yw!v%y!v!w6V!w;'S%y;'S;=`&_<%lO%yX6[V{WOr%ysv%yw!{%y!{!|6q!|;'S%y;'S;=`&_<%lO%yX6vV{WOr%ysv%yw!r%y!r!s7]!s;'S%y;'S;=`&_<%lO%yX7bV{WOr%ysv%yw!g%y!g!h7w!h;'S%y;'S;=`&_<%lO%yX7|X{WOr7wrs8isv7wvw8iw!`7w!`!a9W!a;'S7w;'S;=`9n<%lO7wP8lTO!`8i!`!a8{!a;'S8i;'S;=`9Q<%lO8iP9QOiPP9TP;=`<%l8iX9_TiP{WOr%ysv%yw;'S%y;'S;=`&_<%lO%yX9qP;=`<%l7wX9yX{WOr%ysv%yw!e%y!e!f:f!f#V%y#V#W=t#W;'S%y;'S;=`&_<%lO%yX:kV{WOr%ysv%yw!f%y!f!g;Q!g;'S%y;'S;=`&_<%lO%yX;VV{WOr%ysv%yw!c%y!c!d;l!d;'S%y;'S;=`&_<%lO%yX;qV{WOr%ysv%yw!v%y!v!w<W!w;'S%y;'S;=`&_<%lO%yX<]V{WOr%ysv%yw!c%y!c!d<r!d;'S%y;'S;=`&_<%lO%yX<wV{WOr%ysv%yw!}%y!}#O=^#O;'S%y;'S;=`&_<%lO%yX=eT{WxPOr%ysv%yw;'S%y;'S;=`&_<%lO%yX=yV{WOr%ysv%yw#W%y#W#X>`#X;'S%y;'S;=`&_<%lO%yX>eV{WOr%ysv%yw#T%y#T#U>z#U;'S%y;'S;=`&_<%lO%yX?PV{WOr%ysv%yw#h%y#h#i?f#i;'S%y;'S;=`&_<%lO%yX?kV{WOr%ysv%yw#T%y#T#U<r#U;'S%y;'S;=`&_<%lO%yX@VV{WOr%ysv%yw#c%y#c#d@l#d;'S%y;'S;=`&_<%lO%yX@qV{WOr%ysv%yw#V%y#V#WAW#W;'S%y;'S;=`&_<%lO%yXA]V{WOr%ysv%yw#h%y#h#iAr#i;'S%y;'S;=`&_<%lO%yXAwV{WOr%ysv%yw#m%y#m#nB^#n;'S%y;'S;=`&_<%lO%yXBcV{WOr%ysv%yw#d%y#d#eBx#e;'S%y;'S;=`&_<%lO%yXB}V{WOr%ysv%yw#X%y#X#Y7w#Y;'S%y;'S;=`&_<%lO%yXCkT!PP{WOr%ysv%yw;'S%y;'S;=`&_<%lO%yZDTWaQVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$n_DvW[UVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nZEgYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_!`$n!`!aFV!a;'S$n;'S;=`&e<%lO$nZF`W!OQVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nZGPYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_#P$n#P#QGo#Q;'S$n;'S;=`&e<%lO$nZGvYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_!`$n!`!aHf!a;'S$n;'S;=`&e<%lO$nZHoWwQVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$n\",\n  tokenizers: [startTag, commentContent, piContent, cdataContent, 0, 1, 2, 3],\n  topRules: {\n    \"Document\": [0, 6]\n  },\n  tokenPrec: 0\n});\nexport { parser };","import _classCallCheck from \"D:\\\\react_app\\\\app_1\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nimport { parser } from '@lezer/xml';\nimport { syntaxTree, LRLanguage, indentNodeProp, foldNodeProp, bracketMatchingHandle, LanguageSupport } from '@codemirror/language';\nfunction tagName(doc, tag) {\n  var name = tag && tag.getChild(\"TagName\");\n  return name ? doc.sliceString(name.from, name.to) : \"\";\n}\nfunction elementName(doc, tree) {\n  var tag = tree && tree.firstChild;\n  return !tag || tag.name != \"OpenTag\" ? \"\" : tagName(doc, tag);\n}\nfunction attrName(doc, tag, pos) {\n  var attr = tag && tag.getChildren(\"Attribute\").find(function (a) {\n    return a.from <= pos && a.to >= pos;\n  });\n  var name = attr && attr.getChild(\"AttributeName\");\n  return name ? doc.sliceString(name.from, name.to) : \"\";\n}\nfunction findParentElement(tree) {\n  for (var cur = tree && tree.parent; cur; cur = cur.parent) if (cur.name == \"Element\") return cur;\n  return null;\n}\nfunction findLocation(state, pos) {\n  var _a;\n  var at = syntaxTree(state).resolveInner(pos, -1),\n    inTag = null;\n  for (var cur = at; !inTag && cur.parent; cur = cur.parent) if (cur.name == \"OpenTag\" || cur.name == \"CloseTag\" || cur.name == \"SelfClosingTag\" || cur.name == \"MismatchedCloseTag\") inTag = cur;\n  if (inTag && (inTag.to > pos || inTag.lastChild.type.isError)) {\n    var elt = inTag.parent;\n    if (at.name == \"TagName\") return inTag.name == \"CloseTag\" || inTag.name == \"MismatchedCloseTag\" ? {\n      type: \"closeTag\",\n      from: at.from,\n      context: elt\n    } : {\n      type: \"openTag\",\n      from: at.from,\n      context: findParentElement(elt)\n    };\n    if (at.name == \"AttributeName\") return {\n      type: \"attrName\",\n      from: at.from,\n      context: inTag\n    };\n    if (at.name == \"AttributeValue\") return {\n      type: \"attrValue\",\n      from: at.from,\n      context: inTag\n    };\n    var before = at == inTag || at.name == \"Attribute\" ? at.childBefore(pos) : at;\n    if ((before === null || before === void 0 ? void 0 : before.name) == \"StartTag\") return {\n      type: \"openTag\",\n      from: pos,\n      context: findParentElement(elt)\n    };\n    if ((before === null || before === void 0 ? void 0 : before.name) == \"StartCloseTag\" && before.to <= pos) return {\n      type: \"closeTag\",\n      from: pos,\n      context: elt\n    };\n    if ((before === null || before === void 0 ? void 0 : before.name) == \"Is\") return {\n      type: \"attrValue\",\n      from: pos,\n      context: inTag\n    };\n    if (before) return {\n      type: \"attrName\",\n      from: pos,\n      context: inTag\n    };\n    return null;\n  } else if (at.name == \"StartCloseTag\") {\n    return {\n      type: \"closeTag\",\n      from: pos,\n      context: at.parent\n    };\n  }\n  while (at.parent && at.to == pos && !((_a = at.lastChild) === null || _a === void 0 ? void 0 : _a.type.isError)) at = at.parent;\n  if (at.name == \"Element\" || at.name == \"Text\" || at.name == \"Document\") return {\n    type: \"tag\",\n    from: pos,\n    context: at.name == \"Element\" ? at : findParentElement(at)\n  };\n  return null;\n}\nvar Element = function Element(spec, attrs, attrValues) {\n  _classCallCheck(this, Element);\n  this.attrs = attrs;\n  this.attrValues = attrValues;\n  this.children = [];\n  this.name = spec.name;\n  this.completion = Object.assign(Object.assign({\n    type: \"type\"\n  }, spec.completion || {}), {\n    label: this.name\n  });\n  this.openCompletion = Object.assign(Object.assign({}, this.completion), {\n    label: \"<\" + this.name\n  });\n  this.closeCompletion = Object.assign(Object.assign({}, this.completion), {\n    label: \"</\" + this.name + \">\",\n    boost: 2\n  });\n  this.closeNameCompletion = Object.assign(Object.assign({}, this.completion), {\n    label: this.name + \">\"\n  });\n  this.text = spec.textContent ? spec.textContent.map(function (s) {\n    return {\n      label: s,\n      type: \"text\"\n    };\n  }) : [];\n};\nvar Identifier = /^[:\\-\\.\\w\\u00b7-\\uffff]*$/;\nfunction attrCompletion(spec) {\n  return Object.assign(Object.assign({\n    type: \"property\"\n  }, spec.completion || {}), {\n    label: spec.name\n  });\n}\nfunction valueCompletion(spec) {\n  return typeof spec == \"string\" ? {\n    label: \"\\\"\".concat(spec, \"\\\"\"),\n    type: \"constant\"\n  } : /^\"/.test(spec.label) ? spec : Object.assign(Object.assign({}, spec), {\n    label: \"\\\"\".concat(spec.label, \"\\\"\")\n  });\n}\n/**\nCreate a completion source for the given schema.\n*/\nfunction completeFromSchema(eltSpecs, attrSpecs) {\n  var allAttrs = [],\n    globalAttrs = [];\n  var attrValues = Object.create(null);\n  var _iterator = _createForOfIteratorHelper(attrSpecs),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _s = _step.value;\n      var completion = attrCompletion(_s);\n      allAttrs.push(completion);\n      if (_s.global) globalAttrs.push(completion);\n      if (_s.values) attrValues[_s.name] = _s.values.map(valueCompletion);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var allElements = [],\n    topElements = [];\n  var byName = Object.create(null);\n  var _iterator2 = _createForOfIteratorHelper(eltSpecs),\n    _step2;\n  try {\n    var _loop = function _loop() {\n      var s = _step2.value;\n      var attrs = globalAttrs,\n        attrVals = attrValues;\n      if (s.attributes) attrs = attrs.concat(s.attributes.map(function (s) {\n        if (typeof s == \"string\") return allAttrs.find(function (a) {\n          return a.label == s;\n        }) || {\n          label: s,\n          type: \"property\"\n        };\n        if (s.values) {\n          if (attrVals == attrValues) attrVals = Object.create(attrVals);\n          attrVals[s.name] = s.values.map(valueCompletion);\n        }\n        return attrCompletion(s);\n      }));\n      var elt = new Element(s, attrs, attrVals);\n      byName[elt.name] = elt;\n      allElements.push(elt);\n      if (s.top) topElements.push(elt);\n    };\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  if (!topElements.length) topElements = allElements;\n  for (var i = 0; i < allElements.length; i++) {\n    var s = eltSpecs[i],\n      elt = allElements[i];\n    if (s.children) {\n      var _iterator3 = _createForOfIteratorHelper(s.children),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var ch = _step3.value;\n          if (byName[ch]) elt.children.push(byName[ch]);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    } else {\n      elt.children = allElements;\n    }\n  }\n  return function (cx) {\n    var _a;\n    var doc = cx.state.doc,\n      loc = findLocation(cx.state, cx.pos);\n    if (!loc || loc.type == \"tag\" && !cx.explicit) return null;\n    var type = loc.type,\n      from = loc.from,\n      context = loc.context;\n    if (type == \"openTag\") {\n      var children = topElements;\n      var parentName = elementName(doc, context);\n      if (parentName) {\n        var parent = byName[parentName];\n        children = (parent === null || parent === void 0 ? void 0 : parent.children) || allElements;\n      }\n      return {\n        from: from,\n        options: children.map(function (ch) {\n          return ch.completion;\n        }),\n        validFor: Identifier\n      };\n    } else if (type == \"closeTag\") {\n      var _parentName = elementName(doc, context);\n      return _parentName ? {\n        from: from,\n        to: cx.pos + (doc.sliceString(cx.pos, cx.pos + 1) == \">\" ? 1 : 0),\n        options: [((_a = byName[_parentName]) === null || _a === void 0 ? void 0 : _a.closeNameCompletion) || {\n          label: _parentName + \">\",\n          type: \"type\"\n        }],\n        validFor: Identifier\n      } : null;\n    } else if (type == \"attrName\") {\n      var _parent = byName[tagName(doc, context)];\n      return {\n        from: from,\n        options: (_parent === null || _parent === void 0 ? void 0 : _parent.attrs) || globalAttrs,\n        validFor: Identifier\n      };\n    } else if (type == \"attrValue\") {\n      var attr = attrName(doc, context, from);\n      if (!attr) return null;\n      var _parent2 = byName[tagName(doc, context)];\n      var values = ((_parent2 === null || _parent2 === void 0 ? void 0 : _parent2.attrValues) || attrValues)[attr];\n      if (!values || !values.length) return null;\n      return {\n        from: from,\n        to: cx.pos + (doc.sliceString(cx.pos, cx.pos + 1) == '\"' ? 1 : 0),\n        options: values,\n        validFor: /^\"[^\"]*\"?$/\n      };\n    } else if (type == \"tag\") {\n      var _parentName2 = elementName(doc, context),\n        _parent3 = byName[_parentName2];\n      var closing = [],\n        last = context && context.lastChild;\n      if (_parentName2 && (!last || last.name != \"CloseTag\" || tagName(doc, last) != _parentName2)) closing.push(_parent3 ? _parent3.closeCompletion : {\n        label: \"</\" + _parentName2 + \">\",\n        type: \"type\",\n        boost: 2\n      });\n      var options = closing.concat(((_parent3 === null || _parent3 === void 0 ? void 0 : _parent3.children) || (context ? allElements : topElements)).map(function (e) {\n        return e.openCompletion;\n      }));\n      if (context && (_parent3 === null || _parent3 === void 0 ? void 0 : _parent3.text.length)) {\n        var openTag = context.firstChild;\n        if (openTag.to > cx.pos - 20 && !/\\S/.test(cx.state.sliceDoc(openTag.to, cx.pos))) options = options.concat(_parent3.text);\n      }\n      return {\n        from: from,\n        options: options,\n        validFor: /^<\\/?[:\\-\\.\\w\\u00b7-\\uffff]*$/\n      };\n    } else {\n      return null;\n    }\n  };\n}\n\n/**\nA language provider based on the [Lezer XML\nparser](https://github.com/lezer-parser/xml), extended with\nhighlighting and indentation information.\n*/\nvar xmlLanguage = /*@__PURE__*/LRLanguage.define({\n  name: \"xml\",\n  parser: /*@__PURE__*/parser.configure({\n    props: [/*@__PURE__*/indentNodeProp.add({\n      Element: function Element(context) {\n        var closed = /^\\s*<\\//.test(context.textAfter);\n        return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n      },\n      \"OpenTag CloseTag SelfClosingTag\": function OpenTagCloseTagSelfClosingTag(context) {\n        return context.column(context.node.from) + context.unit;\n      }\n    }), /*@__PURE__*/foldNodeProp.add({\n      Element: function Element(subtree) {\n        var first = subtree.firstChild,\n          last = subtree.lastChild;\n        if (!first || first.name != \"OpenTag\") return null;\n        return {\n          from: first.to,\n          to: last.name == \"CloseTag\" ? last.from : subtree.to\n        };\n      }\n    }), /*@__PURE__*/bracketMatchingHandle.add({\n      \"OpenTag CloseTag\": function OpenTagCloseTag(node) {\n        return node.getChild(\"TagName\");\n      }\n    })]\n  }),\n  languageData: {\n    commentTokens: {\n      block: {\n        open: \"<!--\",\n        close: \"-->\"\n      }\n    },\n    indentOnInput: /^\\s*<\\/$/\n  }\n});\n/**\nXML language support. Includes schema-based autocompletion when\nconfigured.\n*/\nfunction xml() {\n  var conf = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return new LanguageSupport(xmlLanguage, xmlLanguage.data.of({\n    autocomplete: completeFromSchema(conf.elements || [], conf.attributes || [])\n  }));\n}\nexport { completeFromSchema, xml, xmlLanguage };"],"sourceRoot":""}