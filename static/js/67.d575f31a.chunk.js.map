{"version":3,"sources":["D:/react_app/app_1/node_modules/@codemirror/legacy-modes/mode/oz.js"],"names":["wordRegexp","words","RegExp","join","__webpack_require__","r","__webpack_exports__","d","oz","singleOperators","doubleOperators","tripleOperators","middle","end","atoms","commonKeywords","openingKeywords","middleKeywords","endKeywords","tokenBase","stream","state","eatSpace","match","matched","doInCurrentLine","currentIndent","tokenize","tokenFunProc","tokenClass","tokenMeth","quote","ch","next","escaped","test","peek","skipToEnd","eat","tokenComment","eatWhile","hasPassedFirstStage","maybeEnd","name","startState","token","sol","indent","textAfter","cx","trueText","replace","unit","languageData","indentOnInut","allClosings","concat","buildElectricInputRegEx","commentTokens","line","block","open","close"],"mappings":"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","file":"static/js/67.d575f31a.chunk.js","sourcesContent":["function wordRegexp(words) {\n  return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n}\nvar singleOperators = /[\\^@!\\|<>#~\\.\\*\\-\\+\\\\/,=]/;\nvar doubleOperators = /(<-)|(:=)|(=<)|(>=)|(<=)|(<:)|(>:)|(=:)|(\\\\=)|(\\\\=:)|(!!)|(==)|(::)/;\nvar tripleOperators = /(:::)|(\\.\\.\\.)|(=<:)|(>=:)/;\nvar middle = [\"in\", \"then\", \"else\", \"of\", \"elseof\", \"elsecase\", \"elseif\", \"catch\", \"finally\", \"with\", \"require\", \"prepare\", \"import\", \"export\", \"define\", \"do\"];\nvar end = [\"end\"];\nvar atoms = wordRegexp([\"true\", \"false\", \"nil\", \"unit\"]);\nvar commonKeywords = wordRegexp([\"andthen\", \"at\", \"attr\", \"declare\", \"feat\", \"from\", \"lex\", \"mod\", \"div\", \"mode\", \"orelse\", \"parser\", \"prod\", \"prop\", \"scanner\", \"self\", \"syn\", \"token\"]);\nvar openingKeywords = wordRegexp([\"local\", \"proc\", \"fun\", \"case\", \"class\", \"if\", \"cond\", \"or\", \"dis\", \"choice\", \"not\", \"thread\", \"try\", \"raise\", \"lock\", \"for\", \"suchthat\", \"meth\", \"functor\"]);\nvar middleKeywords = wordRegexp(middle);\nvar endKeywords = wordRegexp(end);\n\n// Tokenizers\nfunction tokenBase(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  // Brackets\n  if (stream.match(/[{}]/)) {\n    return \"bracket\";\n  }\n\n  // Special [] keyword\n  if (stream.match('[]')) {\n    return \"keyword\";\n  }\n\n  // Operators\n  if (stream.match(tripleOperators) || stream.match(doubleOperators)) {\n    return \"operator\";\n  }\n\n  // Atoms\n  if (stream.match(atoms)) {\n    return 'atom';\n  }\n\n  // Opening keywords\n  var matched = stream.match(openingKeywords);\n  if (matched) {\n    if (!state.doInCurrentLine) state.currentIndent++;else state.doInCurrentLine = false;\n\n    // Special matching for signatures\n    if (matched[0] == \"proc\" || matched[0] == \"fun\") state.tokenize = tokenFunProc;else if (matched[0] == \"class\") state.tokenize = tokenClass;else if (matched[0] == \"meth\") state.tokenize = tokenMeth;\n    return 'keyword';\n  }\n\n  // Middle and other keywords\n  if (stream.match(middleKeywords) || stream.match(commonKeywords)) {\n    return \"keyword\";\n  }\n\n  // End keywords\n  if (stream.match(endKeywords)) {\n    state.currentIndent--;\n    return 'keyword';\n  }\n\n  // Eat the next char for next comparisons\n  var ch = stream.next();\n\n  // Strings\n  if (ch == '\"' || ch == \"'\") {\n    state.tokenize = tokenString(ch);\n    return state.tokenize(stream, state);\n  }\n\n  // Numbers\n  if (/[~\\d]/.test(ch)) {\n    if (ch == \"~\") {\n      if (!/^[0-9]/.test(stream.peek())) return null;else if (stream.next() == \"0\" && stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^[0-9]*(\\.[0-9]+)?([eE][~+]?[0-9]+)?/)) return \"number\";\n    }\n    if (ch == \"0\" && stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^[0-9]*(\\.[0-9]+)?([eE][~+]?[0-9]+)?/)) return \"number\";\n    return null;\n  }\n\n  // Comments\n  if (ch == \"%\") {\n    stream.skipToEnd();\n    return 'comment';\n  } else if (ch == \"/\") {\n    if (stream.eat(\"*\")) {\n      state.tokenize = tokenComment;\n      return tokenComment(stream, state);\n    }\n  }\n\n  // Single operators\n  if (singleOperators.test(ch)) {\n    return \"operator\";\n  }\n\n  // If nothing match, we skip the entire alphanumerical block\n  stream.eatWhile(/\\w/);\n  return \"variable\";\n}\nfunction tokenClass(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n  stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)/);\n  state.tokenize = tokenBase;\n  return \"type\";\n}\nfunction tokenMeth(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n  stream.match(/([a-zA-Z][A-Za-z0-9_]*)|(`.+`)/);\n  state.tokenize = tokenBase;\n  return \"def\";\n}\nfunction tokenFunProc(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n  if (!state.hasPassedFirstStage && stream.eat(\"{\")) {\n    state.hasPassedFirstStage = true;\n    return \"bracket\";\n  } else if (state.hasPassedFirstStage) {\n    stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)|\\$/);\n    state.hasPassedFirstStage = false;\n    state.tokenize = tokenBase;\n    return \"def\";\n  } else {\n    state.tokenize = tokenBase;\n    return null;\n  }\n}\nfunction tokenComment(stream, state) {\n  var maybeEnd = false,\n    ch;\n  while (ch = stream.next()) {\n    if (ch == \"/\" && maybeEnd) {\n      state.tokenize = tokenBase;\n      break;\n    }\n    maybeEnd = ch == \"*\";\n  }\n  return \"comment\";\n}\nfunction tokenString(quote) {\n  return function (stream, state) {\n    var escaped = false,\n      next,\n      end = false;\n    while ((next = stream.next()) != null) {\n      if (next == quote && !escaped) {\n        end = true;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    if (end || !escaped) state.tokenize = tokenBase;\n    return \"string\";\n  };\n}\nfunction buildElectricInputRegEx() {\n  // Reindentation should occur on [] or on a match of any of\n  // the block closing keywords, at the end of a line.\n  var allClosings = middle.concat(end);\n  return new RegExp(\"[\\\\[\\\\]]|(\" + allClosings.join(\"|\") + \")$\");\n}\nexport var oz = {\n  name: \"oz\",\n  startState: function startState() {\n    return {\n      tokenize: tokenBase,\n      currentIndent: 0,\n      doInCurrentLine: false,\n      hasPassedFirstStage: false\n    };\n  },\n  token: function token(stream, state) {\n    if (stream.sol()) state.doInCurrentLine = 0;\n    return state.tokenize(stream, state);\n  },\n  indent: function indent(state, textAfter, cx) {\n    var trueText = textAfter.replace(/^\\s+|\\s+$/g, '');\n    if (trueText.match(endKeywords) || trueText.match(middleKeywords) || trueText.match(/(\\[])/)) return cx.unit * (state.currentIndent - 1);\n    if (state.currentIndent < 0) return 0;\n    return state.currentIndent * cx.unit;\n  },\n  languageData: {\n    indentOnInut: buildElectricInputRegEx(),\n    commentTokens: {\n      line: \"%\",\n      block: {\n        open: \"/*\",\n        close: \"*/\"\n      }\n    }\n  }\n};"],"sourceRoot":""}