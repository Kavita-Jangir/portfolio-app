{"version":3,"sources":["D:/react_app/app_1/node_modules/@codemirror/legacy-modes/mode/erlang.js"],"names":["__webpack_require__","r","__webpack_exports__","d","erlang","typeWords","keywordWords","separatorRE","separatorWords","operatorAtomWords","operatorSymbolRE","operatorSymbolWords","openParenRE","openParenWords","closeParenRE","closeParenWords","guardWords","bifWords","anumRE","escapesRE","nongreedy","stream","re","words","current","length","test","backUp","peek","next","is_member","greedy","doubleQuote","quote","singleQuote","quoteChar","escapeChar","eol","ch","element","list","indexOf","rval","state","type","token","tokenStack","s","last","pop","push","maybe_drop_pre","slice","g","i","e","m","E","maybe_drop_post","pushToken","aToken","column","indentation","realToken","tok","col","ind","typ","indent","fakeToken","peekToken","depth","len","dep","stack","tt","tokens","ss","concat","getToken","objs","getTokenIndex","truthy","propname","propvals","x","name","startState","in_string","in_atom","eatSpace","match","skipToEnd","eatWhile","w","lookahead","digitRE","eat","textAfter","cx","t","wordAfter","str","index","wordafter","currT","prevT","unit","postcommaToken","stop","oper","defaultToken","languageData","commentTokens","line"],"mappings":"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","file":"static/js/43.4e7f7bb5.chunk.js","sourcesContent":["/////////////////////////////////////////////////////////////////////////////\n// constants\n\nvar typeWords = [\"-type\", \"-spec\", \"-export_type\", \"-opaque\"];\nvar keywordWords = [\"after\", \"begin\", \"catch\", \"case\", \"cond\", \"end\", \"fun\", \"if\", \"let\", \"of\", \"query\", \"receive\", \"try\", \"when\"];\nvar separatorRE = /[\\->,;]/;\nvar separatorWords = [\"->\", \";\", \",\"];\nvar operatorAtomWords = [\"and\", \"andalso\", \"band\", \"bnot\", \"bor\", \"bsl\", \"bsr\", \"bxor\", \"div\", \"not\", \"or\", \"orelse\", \"rem\", \"xor\"];\nvar operatorSymbolRE = /[\\+\\-\\*\\/<>=\\|:!]/;\nvar operatorSymbolWords = [\"=\", \"+\", \"-\", \"*\", \"/\", \">\", \">=\", \"<\", \"=<\", \"=:=\", \"==\", \"=/=\", \"/=\", \"||\", \"<-\", \"!\"];\nvar openParenRE = /[<\\(\\[\\{]/;\nvar openParenWords = [\"<<\", \"(\", \"[\", \"{\"];\nvar closeParenRE = /[>\\)\\]\\}]/;\nvar closeParenWords = [\"}\", \"]\", \")\", \">>\"];\nvar guardWords = [\"is_atom\", \"is_binary\", \"is_bitstring\", \"is_boolean\", \"is_float\", \"is_function\", \"is_integer\", \"is_list\", \"is_number\", \"is_pid\", \"is_port\", \"is_record\", \"is_reference\", \"is_tuple\", \"atom\", \"binary\", \"bitstring\", \"boolean\", \"function\", \"integer\", \"list\", \"number\", \"pid\", \"port\", \"record\", \"reference\", \"tuple\"];\nvar bifWords = [\"abs\", \"adler32\", \"adler32_combine\", \"alive\", \"apply\", \"atom_to_binary\", \"atom_to_list\", \"binary_to_atom\", \"binary_to_existing_atom\", \"binary_to_list\", \"binary_to_term\", \"bit_size\", \"bitstring_to_list\", \"byte_size\", \"check_process_code\", \"contact_binary\", \"crc32\", \"crc32_combine\", \"date\", \"decode_packet\", \"delete_module\", \"disconnect_node\", \"element\", \"erase\", \"exit\", \"float\", \"float_to_list\", \"garbage_collect\", \"get\", \"get_keys\", \"group_leader\", \"halt\", \"hd\", \"integer_to_list\", \"internal_bif\", \"iolist_size\", \"iolist_to_binary\", \"is_alive\", \"is_atom\", \"is_binary\", \"is_bitstring\", \"is_boolean\", \"is_float\", \"is_function\", \"is_integer\", \"is_list\", \"is_number\", \"is_pid\", \"is_port\", \"is_process_alive\", \"is_record\", \"is_reference\", \"is_tuple\", \"length\", \"link\", \"list_to_atom\", \"list_to_binary\", \"list_to_bitstring\", \"list_to_existing_atom\", \"list_to_float\", \"list_to_integer\", \"list_to_pid\", \"list_to_tuple\", \"load_module\", \"make_ref\", \"module_loaded\", \"monitor_node\", \"node\", \"node_link\", \"node_unlink\", \"nodes\", \"notalive\", \"now\", \"open_port\", \"pid_to_list\", \"port_close\", \"port_command\", \"port_connect\", \"port_control\", \"pre_loaded\", \"process_flag\", \"process_info\", \"processes\", \"purge_module\", \"put\", \"register\", \"registered\", \"round\", \"self\", \"setelement\", \"size\", \"spawn\", \"spawn_link\", \"spawn_monitor\", \"spawn_opt\", \"split_binary\", \"statistics\", \"term_to_binary\", \"time\", \"throw\", \"tl\", \"trunc\", \"tuple_size\", \"tuple_to_list\", \"unlink\", \"unregister\", \"whereis\"];\n\n// upper case: [A-Z] [Ø-Þ] [À-Ö]\n// lower case: [a-z] [ß-ö] [ø-ÿ]\nvar anumRE = /[\\w@Ø-ÞÀ-Öß-öø-ÿ]/;\nvar escapesRE = /[0-7]{1,3}|[bdefnrstv\\\\\"']|\\^[a-zA-Z]|x[0-9a-zA-Z]{2}|x{[0-9a-zA-Z]+}/;\n\n/////////////////////////////////////////////////////////////////////////////\n// tokenizer\n\nfunction tokenizer(stream, state) {\n  // in multi-line string\n  if (state.in_string) {\n    state.in_string = !doubleQuote(stream);\n    return rval(state, stream, \"string\");\n  }\n\n  // in multi-line atom\n  if (state.in_atom) {\n    state.in_atom = !singleQuote(stream);\n    return rval(state, stream, \"atom\");\n  }\n\n  // whitespace\n  if (stream.eatSpace()) {\n    return rval(state, stream, \"whitespace\");\n  }\n\n  // attributes and type specs\n  if (!peekToken(state) && stream.match(/-\\s*[a-zß-öø-ÿ][\\wØ-ÞÀ-Öß-öø-ÿ]*/)) {\n    if (is_member(stream.current(), typeWords)) {\n      return rval(state, stream, \"type\");\n    } else {\n      return rval(state, stream, \"attribute\");\n    }\n  }\n  var ch = stream.next();\n\n  // comment\n  if (ch == '%') {\n    stream.skipToEnd();\n    return rval(state, stream, \"comment\");\n  }\n\n  // colon\n  if (ch == \":\") {\n    return rval(state, stream, \"colon\");\n  }\n\n  // macro\n  if (ch == '?') {\n    stream.eatSpace();\n    stream.eatWhile(anumRE);\n    return rval(state, stream, \"macro\");\n  }\n\n  // record\n  if (ch == \"#\") {\n    stream.eatSpace();\n    stream.eatWhile(anumRE);\n    return rval(state, stream, \"record\");\n  }\n\n  // dollar escape\n  if (ch == \"$\") {\n    if (stream.next() == \"\\\\\" && !stream.match(escapesRE)) {\n      return rval(state, stream, \"error\");\n    }\n    return rval(state, stream, \"number\");\n  }\n\n  // dot\n  if (ch == \".\") {\n    return rval(state, stream, \"dot\");\n  }\n\n  // quoted atom\n  if (ch == '\\'') {\n    if (!(state.in_atom = !singleQuote(stream))) {\n      if (stream.match(/\\s*\\/\\s*[0-9]/, false)) {\n        stream.match(/\\s*\\/\\s*[0-9]/, true);\n        return rval(state, stream, \"fun\"); // 'f'/0 style fun\n      }\n\n      if (stream.match(/\\s*\\(/, false) || stream.match(/\\s*:/, false)) {\n        return rval(state, stream, \"function\");\n      }\n    }\n    return rval(state, stream, \"atom\");\n  }\n\n  // string\n  if (ch == '\"') {\n    state.in_string = !doubleQuote(stream);\n    return rval(state, stream, \"string\");\n  }\n\n  // variable\n  if (/[A-Z_Ø-ÞÀ-Ö]/.test(ch)) {\n    stream.eatWhile(anumRE);\n    return rval(state, stream, \"variable\");\n  }\n\n  // atom/keyword/BIF/function\n  if (/[a-z_ß-öø-ÿ]/.test(ch)) {\n    stream.eatWhile(anumRE);\n    if (stream.match(/\\s*\\/\\s*[0-9]/, false)) {\n      stream.match(/\\s*\\/\\s*[0-9]/, true);\n      return rval(state, stream, \"fun\"); // f/0 style fun\n    }\n\n    var w = stream.current();\n    if (is_member(w, keywordWords)) {\n      return rval(state, stream, \"keyword\");\n    } else if (is_member(w, operatorAtomWords)) {\n      return rval(state, stream, \"operator\");\n    } else if (stream.match(/\\s*\\(/, false)) {\n      // 'put' and 'erlang:put' are bifs, 'foo:put' is not\n      if (is_member(w, bifWords) && (peekToken(state).token != \":\" || peekToken(state, 2).token == \"erlang\")) {\n        return rval(state, stream, \"builtin\");\n      } else if (is_member(w, guardWords)) {\n        return rval(state, stream, \"guard\");\n      } else {\n        return rval(state, stream, \"function\");\n      }\n    } else if (lookahead(stream) == \":\") {\n      if (w == \"erlang\") {\n        return rval(state, stream, \"builtin\");\n      } else {\n        return rval(state, stream, \"function\");\n      }\n    } else if (is_member(w, [\"true\", \"false\"])) {\n      return rval(state, stream, \"boolean\");\n    } else {\n      return rval(state, stream, \"atom\");\n    }\n  }\n\n  // number\n  var digitRE = /[0-9]/;\n  var radixRE = /[0-9a-zA-Z]/; // 36#zZ style int\n  if (digitRE.test(ch)) {\n    stream.eatWhile(digitRE);\n    if (stream.eat('#')) {\n      // 36#aZ  style integer\n      if (!stream.eatWhile(radixRE)) {\n        stream.backUp(1); //\"36#\" - syntax error\n      }\n    } else if (stream.eat('.')) {\n      // float\n      if (!stream.eatWhile(digitRE)) {\n        stream.backUp(1); // \"3.\" - probably end of function\n      } else {\n        if (stream.eat(/[eE]/)) {\n          // float with exponent\n          if (stream.eat(/[-+]/)) {\n            if (!stream.eatWhile(digitRE)) {\n              stream.backUp(2); // \"2e-\" - syntax error\n            }\n          } else {\n            if (!stream.eatWhile(digitRE)) {\n              stream.backUp(1); // \"2e\" - syntax error\n            }\n          }\n        }\n      }\n    }\n\n    return rval(state, stream, \"number\"); // normal integer\n  }\n\n  // open parens\n  if (nongreedy(stream, openParenRE, openParenWords)) {\n    return rval(state, stream, \"open_paren\");\n  }\n\n  // close parens\n  if (nongreedy(stream, closeParenRE, closeParenWords)) {\n    return rval(state, stream, \"close_paren\");\n  }\n\n  // separators\n  if (greedy(stream, separatorRE, separatorWords)) {\n    return rval(state, stream, \"separator\");\n  }\n\n  // operators\n  if (greedy(stream, operatorSymbolRE, operatorSymbolWords)) {\n    return rval(state, stream, \"operator\");\n  }\n  return rval(state, stream, null);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// utilities\nfunction nongreedy(stream, re, words) {\n  if (stream.current().length == 1 && re.test(stream.current())) {\n    stream.backUp(1);\n    while (re.test(stream.peek())) {\n      stream.next();\n      if (is_member(stream.current(), words)) {\n        return true;\n      }\n    }\n    stream.backUp(stream.current().length - 1);\n  }\n  return false;\n}\nfunction greedy(stream, re, words) {\n  if (stream.current().length == 1 && re.test(stream.current())) {\n    while (re.test(stream.peek())) {\n      stream.next();\n    }\n    while (0 < stream.current().length) {\n      if (is_member(stream.current(), words)) {\n        return true;\n      } else {\n        stream.backUp(1);\n      }\n    }\n    stream.next();\n  }\n  return false;\n}\nfunction doubleQuote(stream) {\n  return quote(stream, '\"', '\\\\');\n}\nfunction singleQuote(stream) {\n  return quote(stream, '\\'', '\\\\');\n}\nfunction quote(stream, quoteChar, escapeChar) {\n  while (!stream.eol()) {\n    var ch = stream.next();\n    if (ch == quoteChar) {\n      return true;\n    } else if (ch == escapeChar) {\n      stream.next();\n    }\n  }\n  return false;\n}\nfunction lookahead(stream) {\n  var m = stream.match(/^\\s*([^\\s%])/, false);\n  return m ? m[1] : \"\";\n}\nfunction is_member(element, list) {\n  return -1 < list.indexOf(element);\n}\nfunction rval(state, stream, type) {\n  // parse stack\n  pushToken(state, realToken(type, stream));\n\n  // map erlang token type to CodeMirror style class\n  //     erlang             -> CodeMirror tag\n  switch (type) {\n    case \"atom\":\n      return \"atom\";\n    case \"attribute\":\n      return \"attribute\";\n    case \"boolean\":\n      return \"atom\";\n    case \"builtin\":\n      return \"builtin\";\n    case \"close_paren\":\n      return null;\n    case \"colon\":\n      return null;\n    case \"comment\":\n      return \"comment\";\n    case \"dot\":\n      return null;\n    case \"error\":\n      return \"error\";\n    case \"fun\":\n      return \"meta\";\n    case \"function\":\n      return \"tag\";\n    case \"guard\":\n      return \"property\";\n    case \"keyword\":\n      return \"keyword\";\n    case \"macro\":\n      return \"macroName\";\n    case \"number\":\n      return \"number\";\n    case \"open_paren\":\n      return null;\n    case \"operator\":\n      return \"operator\";\n    case \"record\":\n      return \"bracket\";\n    case \"separator\":\n      return null;\n    case \"string\":\n      return \"string\";\n    case \"type\":\n      return \"def\";\n    case \"variable\":\n      return \"variable\";\n    default:\n      return null;\n  }\n}\nfunction aToken(tok, col, ind, typ) {\n  return {\n    token: tok,\n    column: col,\n    indent: ind,\n    type: typ\n  };\n}\nfunction realToken(type, stream) {\n  return aToken(stream.current(), stream.column(), stream.indentation(), type);\n}\nfunction fakeToken(type) {\n  return aToken(type, 0, 0, type);\n}\nfunction peekToken(state, depth) {\n  var len = state.tokenStack.length;\n  var dep = depth ? depth : 1;\n  if (len < dep) {\n    return false;\n  } else {\n    return state.tokenStack[len - dep];\n  }\n}\nfunction pushToken(state, token) {\n  if (!(token.type == \"comment\" || token.type == \"whitespace\")) {\n    state.tokenStack = maybe_drop_pre(state.tokenStack, token);\n    state.tokenStack = maybe_drop_post(state.tokenStack);\n  }\n}\nfunction maybe_drop_pre(s, token) {\n  var last = s.length - 1;\n  if (0 < last && s[last].type === \"record\" && token.type === \"dot\") {\n    s.pop();\n  } else if (0 < last && s[last].type === \"group\") {\n    s.pop();\n    s.push(token);\n  } else {\n    s.push(token);\n  }\n  return s;\n}\nfunction maybe_drop_post(s) {\n  if (!s.length) return s;\n  var last = s.length - 1;\n  if (s[last].type === \"dot\") {\n    return [];\n  }\n  if (last > 1 && s[last].type === \"fun\" && s[last - 1].token === \"fun\") {\n    return s.slice(0, last - 1);\n  }\n  switch (s[last].token) {\n    case \"}\":\n      return d(s, {\n        g: [\"{\"]\n      });\n    case \"]\":\n      return d(s, {\n        i: [\"[\"]\n      });\n    case \")\":\n      return d(s, {\n        i: [\"(\"]\n      });\n    case \">>\":\n      return d(s, {\n        i: [\"<<\"]\n      });\n    case \"end\":\n      return d(s, {\n        i: [\"begin\", \"case\", \"fun\", \"if\", \"receive\", \"try\"]\n      });\n    case \",\":\n      return d(s, {\n        e: [\"begin\", \"try\", \"when\", \"->\", \",\", \"(\", \"[\", \"{\", \"<<\"]\n      });\n    case \"->\":\n      return d(s, {\n        r: [\"when\"],\n        m: [\"try\", \"if\", \"case\", \"receive\"]\n      });\n    case \";\":\n      return d(s, {\n        E: [\"case\", \"fun\", \"if\", \"receive\", \"try\", \"when\"]\n      });\n    case \"catch\":\n      return d(s, {\n        e: [\"try\"]\n      });\n    case \"of\":\n      return d(s, {\n        e: [\"case\"]\n      });\n    case \"after\":\n      return d(s, {\n        e: [\"receive\", \"try\"]\n      });\n    default:\n      return s;\n  }\n}\nfunction d(stack, tt) {\n  // stack is a stack of Token objects.\n  // tt is an object; {type:tokens}\n  // type is a char, tokens is a list of token strings.\n  // The function returns (possibly truncated) stack.\n  // It will descend the stack, looking for a Token such that Token.token\n  //  is a member of tokens. If it does not find that, it will normally (but\n  //  see \"E\" below) return stack. If it does find a match, it will remove\n  //  all the Tokens between the top and the matched Token.\n  // If type is \"m\", that is all it does.\n  // If type is \"i\", it will also remove the matched Token and the top Token.\n  // If type is \"g\", like \"i\", but add a fake \"group\" token at the top.\n  // If type is \"r\", it will remove the matched Token, but not the top Token.\n  // If type is \"e\", it will keep the matched Token but not the top Token.\n  // If type is \"E\", it behaves as for type \"e\", except if there is no match,\n  //  in which case it will return an empty stack.\n\n  for (var type in tt) {\n    var len = stack.length - 1;\n    var tokens = tt[type];\n    for (var i = len - 1; -1 < i; i--) {\n      if (is_member(stack[i].token, tokens)) {\n        var ss = stack.slice(0, i);\n        switch (type) {\n          case \"m\":\n            return ss.concat(stack[i]).concat(stack[len]);\n          case \"r\":\n            return ss.concat(stack[len]);\n          case \"i\":\n            return ss;\n          case \"g\":\n            return ss.concat(fakeToken(\"group\"));\n          case \"E\":\n            return ss.concat(stack[i]);\n          case \"e\":\n            return ss.concat(stack[i]);\n        }\n      }\n    }\n  }\n  return type == \"E\" ? [] : stack;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// indenter\n\nfunction indenter(state, textAfter, cx) {\n  var t;\n  var wordAfter = wordafter(textAfter);\n  var currT = peekToken(state, 1);\n  var prevT = peekToken(state, 2);\n  if (state.in_string || state.in_atom) {\n    return null;\n  } else if (!prevT) {\n    return 0;\n  } else if (currT.token == \"when\") {\n    return currT.column + cx.unit;\n  } else if (wordAfter === \"when\" && prevT.type === \"function\") {\n    return prevT.indent + cx.unit;\n  } else if (wordAfter === \"(\" && currT.token === \"fun\") {\n    return currT.column + 3;\n  } else if (wordAfter === \"catch\" && (t = getToken(state, [\"try\"]))) {\n    return t.column;\n  } else if (is_member(wordAfter, [\"end\", \"after\", \"of\"])) {\n    t = getToken(state, [\"begin\", \"case\", \"fun\", \"if\", \"receive\", \"try\"]);\n    return t ? t.column : null;\n  } else if (is_member(wordAfter, closeParenWords)) {\n    t = getToken(state, openParenWords);\n    return t ? t.column : null;\n  } else if (is_member(currT.token, [\",\", \"|\", \"||\"]) || is_member(wordAfter, [\",\", \"|\", \"||\"])) {\n    t = postcommaToken(state);\n    return t ? t.column + t.token.length : cx.unit;\n  } else if (currT.token == \"->\") {\n    if (is_member(prevT.token, [\"receive\", \"case\", \"if\", \"try\"])) {\n      return prevT.column + cx.unit + cx.unit;\n    } else {\n      return prevT.column + cx.unit;\n    }\n  } else if (is_member(currT.token, openParenWords)) {\n    return currT.column + currT.token.length;\n  } else {\n    t = defaultToken(state);\n    return truthy(t) ? t.column + cx.unit : 0;\n  }\n}\nfunction wordafter(str) {\n  var m = str.match(/,|[a-z]+|\\}|\\]|\\)|>>|\\|+|\\(/);\n  return truthy(m) && m.index === 0 ? m[0] : \"\";\n}\nfunction postcommaToken(state) {\n  var objs = state.tokenStack.slice(0, -1);\n  var i = getTokenIndex(objs, \"type\", [\"open_paren\"]);\n  return truthy(objs[i]) ? objs[i] : false;\n}\nfunction defaultToken(state) {\n  var objs = state.tokenStack;\n  var stop = getTokenIndex(objs, \"type\", [\"open_paren\", \"separator\", \"keyword\"]);\n  var oper = getTokenIndex(objs, \"type\", [\"operator\"]);\n  if (truthy(stop) && truthy(oper) && stop < oper) {\n    return objs[stop + 1];\n  } else if (truthy(stop)) {\n    return objs[stop];\n  } else {\n    return false;\n  }\n}\nfunction getToken(state, tokens) {\n  var objs = state.tokenStack;\n  var i = getTokenIndex(objs, \"token\", tokens);\n  return truthy(objs[i]) ? objs[i] : false;\n}\nfunction getTokenIndex(objs, propname, propvals) {\n  for (var i = objs.length - 1; -1 < i; i--) {\n    if (is_member(objs[i][propname], propvals)) {\n      return i;\n    }\n  }\n  return false;\n}\nfunction truthy(x) {\n  return x !== false && x != null;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// this object defines the mode\n\nexport var erlang = {\n  name: \"erlang\",\n  startState: function startState() {\n    return {\n      tokenStack: [],\n      in_string: false,\n      in_atom: false\n    };\n  },\n  token: tokenizer,\n  indent: indenter,\n  languageData: {\n    commentTokens: {\n      line: \"%\"\n    }\n  }\n};"],"sourceRoot":""}