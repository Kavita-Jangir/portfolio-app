{"version":3,"sources":["D:/react_app/app_1/node_modules/@codemirror/legacy-modes/mode/asn1.js"],"names":["words","str","obj","split","i","length","__webpack_require__","r","__webpack_exports__","d","asn1","defaults","keywords","cmipVerbs","compareTypes","status","tags","storage","modifier","accessTypes","multiLineStrings","parserConfig","curPunc","indentStatements","isOperatorChar","tokenBase","stream","state","quote","ch","next","tokenize","escaped","end","afterNext","peek","toLowerCase","test","eat","skipToEnd","eatWhile","cur","current","propertyIsEnumerable","Context","indented","column","type","align","prev","this","pushContext","col","indent","context","popContext","t","name","startState","startOfLine","token","ctx","sol","indentation","eatSpace","style","languageData","indentOnInput","commentTokens","line"],"mappings":"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","file":"static/js/26.924c15ae.chunk.js","sourcesContent":["function words(str) {\n  var obj = {},\n    words = str.split(\" \");\n  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n  return obj;\n}\nvar defaults = {\n  keywords: words(\"DEFINITIONS OBJECTS IF DERIVED INFORMATION ACTION\" + \" REPLY ANY NAMED CHARACTERIZED BEHAVIOUR REGISTERED\" + \" WITH AS IDENTIFIED CONSTRAINED BY PRESENT BEGIN\" + \" IMPORTS FROM UNITS SYNTAX MIN-ACCESS MAX-ACCESS\" + \" MINACCESS MAXACCESS REVISION STATUS DESCRIPTION\" + \" SEQUENCE SET COMPONENTS OF CHOICE DistinguishedName\" + \" ENUMERATED SIZE MODULE END INDEX AUGMENTS EXTENSIBILITY\" + \" IMPLIED EXPORTS\"),\n  cmipVerbs: words(\"ACTIONS ADD GET NOTIFICATIONS REPLACE REMOVE\"),\n  compareTypes: words(\"OPTIONAL DEFAULT MANAGED MODULE-TYPE MODULE_IDENTITY\" + \" MODULE-COMPLIANCE OBJECT-TYPE OBJECT-IDENTITY\" + \" OBJECT-COMPLIANCE MODE CONFIRMED CONDITIONAL\" + \" SUBORDINATE SUPERIOR CLASS TRUE FALSE NULL\" + \" TEXTUAL-CONVENTION\"),\n  status: words(\"current deprecated mandatory obsolete\"),\n  tags: words(\"APPLICATION AUTOMATIC EXPLICIT IMPLICIT PRIVATE TAGS\" + \" UNIVERSAL\"),\n  storage: words(\"BOOLEAN INTEGER OBJECT IDENTIFIER BIT OCTET STRING\" + \" UTCTime InterfaceIndex IANAifType CMIP-Attribute\" + \" REAL PACKAGE PACKAGES IpAddress PhysAddress\" + \" NetworkAddress BITS BMPString TimeStamp TimeTicks\" + \" TruthValue RowStatus DisplayString GeneralString\" + \" GraphicString IA5String NumericString\" + \" PrintableString SnmpAdminString TeletexString\" + \" UTF8String VideotexString VisibleString StringStore\" + \" ISO646String T61String UniversalString Unsigned32\" + \" Integer32 Gauge Gauge32 Counter Counter32 Counter64\"),\n  modifier: words(\"ATTRIBUTE ATTRIBUTES MANDATORY-GROUP MANDATORY-GROUPS\" + \" GROUP GROUPS ELEMENTS EQUALITY ORDERING SUBSTRINGS\" + \" DEFINED\"),\n  accessTypes: words(\"not-accessible accessible-for-notify read-only\" + \" read-create read-write\"),\n  multiLineStrings: true\n};\nexport function asn1(parserConfig) {\n  var keywords = parserConfig.keywords || defaults.keywords,\n    cmipVerbs = parserConfig.cmipVerbs || defaults.cmipVerbs,\n    compareTypes = parserConfig.compareTypes || defaults.compareTypes,\n    status = parserConfig.status || defaults.status,\n    tags = parserConfig.tags || defaults.tags,\n    storage = parserConfig.storage || defaults.storage,\n    modifier = parserConfig.modifier || defaults.modifier,\n    accessTypes = parserConfig.accessTypes || defaults.accessTypes,\n    multiLineStrings = parserConfig.multiLineStrings || defaults.multiLineStrings,\n    indentStatements = parserConfig.indentStatements !== false;\n  var isOperatorChar = /[\\|\\^]/;\n  var curPunc;\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    }\n    if (/[\\[\\]\\(\\){}:=,;]/.test(ch)) {\n      curPunc = ch;\n      return \"punctuation\";\n    }\n    if (ch == \"-\") {\n      if (stream.eat(\"-\")) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n    }\n    if (/\\d/.test(ch)) {\n      stream.eatWhile(/[\\w\\.]/);\n      return \"number\";\n    }\n    if (isOperatorChar.test(ch)) {\n      stream.eatWhile(isOperatorChar);\n      return \"operator\";\n    }\n    stream.eatWhile(/[\\w\\-]/);\n    var cur = stream.current();\n    if (keywords.propertyIsEnumerable(cur)) return \"keyword\";\n    if (cmipVerbs.propertyIsEnumerable(cur)) return \"variableName\";\n    if (compareTypes.propertyIsEnumerable(cur)) return \"atom\";\n    if (status.propertyIsEnumerable(cur)) return \"comment\";\n    if (tags.propertyIsEnumerable(cur)) return \"typeName\";\n    if (storage.propertyIsEnumerable(cur)) return \"modifier\";\n    if (modifier.propertyIsEnumerable(cur)) return \"modifier\";\n    if (accessTypes.propertyIsEnumerable(cur)) return \"modifier\";\n    return \"variableName\";\n  }\n  function tokenString(quote) {\n    return function (stream, state) {\n      var escaped = false,\n        next,\n        end = false;\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) {\n          var afterNext = stream.peek();\n          //look if the character if the quote is like the B in '10100010'B\n          if (afterNext) {\n            afterNext = afterNext.toLowerCase();\n            if (afterNext == \"b\" || afterNext == \"h\" || afterNext == \"o\") stream.next();\n          }\n          end = true;\n          break;\n        }\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (end || !(escaped || multiLineStrings)) state.tokenize = null;\n      return \"string\";\n    };\n  }\n  function Context(indented, column, type, align, prev) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.align = align;\n    this.prev = prev;\n  }\n  function pushContext(state, col, type) {\n    var indent = state.indented;\n    if (state.context && state.context.type == \"statement\") indent = state.context.indented;\n    return state.context = new Context(indent, col, type, null, state.context);\n  }\n  function popContext(state) {\n    var t = state.context.type;\n    if (t == \")\" || t == \"]\" || t == \"}\") state.indented = state.context.indented;\n    return state.context = state.context.prev;\n  }\n\n  //Interface\n  return {\n    name: \"asn1\",\n    startState: function startState() {\n      return {\n        tokenize: null,\n        context: new Context(-2, 0, \"top\", false),\n        indented: 0,\n        startOfLine: true\n      };\n    },\n    token: function token(stream, state) {\n      var ctx = state.context;\n      if (stream.sol()) {\n        if (ctx.align == null) ctx.align = false;\n        state.indented = stream.indentation();\n        state.startOfLine = true;\n      }\n      if (stream.eatSpace()) return null;\n      curPunc = null;\n      var style = (state.tokenize || tokenBase)(stream, state);\n      if (style == \"comment\") return style;\n      if (ctx.align == null) ctx.align = true;\n      if ((curPunc == \";\" || curPunc == \":\" || curPunc == \",\") && ctx.type == \"statement\") {\n        popContext(state);\n      } else if (curPunc == \"{\") pushContext(state, stream.column(), \"}\");else if (curPunc == \"[\") pushContext(state, stream.column(), \"]\");else if (curPunc == \"(\") pushContext(state, stream.column(), \")\");else if (curPunc == \"}\") {\n        while (ctx.type == \"statement\") ctx = popContext(state);\n        if (ctx.type == \"}\") ctx = popContext(state);\n        while (ctx.type == \"statement\") ctx = popContext(state);\n      } else if (curPunc == ctx.type) popContext(state);else if (indentStatements && ((ctx.type == \"}\" || ctx.type == \"top\") && curPunc != ';' || ctx.type == \"statement\" && curPunc == \"newstatement\")) pushContext(state, stream.column(), \"statement\");\n      state.startOfLine = false;\n      return style;\n    },\n    languageData: {\n      indentOnInput: /^\\s*[{}]$/,\n      commentTokens: {\n        line: \"--\"\n      }\n    }\n  };\n}\n;"],"sourceRoot":""}