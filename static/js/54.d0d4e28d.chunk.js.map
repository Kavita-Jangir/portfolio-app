{"version":3,"sources":["D:/react_app/app_1/node_modules/@codemirror/legacy-modes/mode/javascript.js"],"names":["mkJavaScript","parserConfig","type","content","statementIndent","jsonldMode","jsonld","jsonMode","json","isTS","typescript","wordRE","wordCharacters","keywords","kw","style","A","B","C","D","operator","atom","if","while","with","else","do","try","finally","return","break","continue","new","delete","void","throw","debugger","var","const","let","function","catch","for","switch","case","default","in","typeof","instanceof","true","false","null","undefined","NaN","Infinity","this","class","super","yield","export","import","extends","await","isOperatorChar","isJsonldKeyword","ret","tp","cont","tokenBase","stream","state","quote","ch","next","tokenize","escaped","peek","match","test","eat","tokenComment","skipToEnd","backUp","lastType","string","slice","pos","expressionAllowed","inSet","readRegexp","current","tokenQuasi","eatWhile","start","lexical","word","propertyIsEnumerable","maybeEnd","brackets","findFatArrow","fatArrowAt","arrow","indexOf","m","exec","index","depth","sawSomething","charAt","bracket","atomicTypes","number","variable","regexp","jsonld-keyword","JSLexical","indented","column","align","prev","info","inScope","varname","v","localVars","name","cx","context","vars","marked","cc","pass","i","arguments","length","push","apply","inList","list","register","block","newContext","registerVarScoped","inner","Context","Var","globalVars","isModifier","defaultVars","pushcontext","pushblockcontext","popcontext","pushlex","result","indent","outer","lex","poplex","expect","wanted","exp","statement","value","vardef","parenExpr","maybeexpression","pop","maybeelse","functiondef","forspec","className","enumdef","typename","typeexpr","pattern","expression","maybelabel","maybeCatchBinding","afterExport","afterImport","funarg","expressionInner","expressionNoComma","noComma","body","arrowBodyNoComma","arrowBody","commasep","maybeop","maybeoperatorNoComma","maybeoperatorComma","hasOwnProperty","classExpression","arrayLiteral","contCommasep","objprop","quasi","targetNoComma","target","maybeTypeArgs","maybeTarget","me","expr","property","continueQuasi","_","getterSetter","afterprop","maybetype","what","end","sep","proceed","maybetypeOrIn","mayberettype","isKW","afterType","typeprops","typearg","maybeReturnType","quasiType","typeprop","functiondecl","continueQuasiType","typeparam","maybeTypeDefault","maybeAssign","vardefCont","eltpattern","proppattern","_type","forspec1","forspec2","classNameAfter","classBody","classfield","maybeFrom","exportField","importSpec","maybeMoreImports","maybeAs","enummember","startState","indentUnit","token","sol","indentation","eatSpace","parseJS","textAfter","top","firstChar","c","closing","unit","isContinuedStatement","doubleIndentSwitch","languageData","indentOnInput","commentTokens","line","open","close","closeBrackets","wordChars","__webpack_require__","r","__webpack_exports__","d","javascript"],"mappings":"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","file":"static/js/54.d0d4e28d.chunk.js","sourcesContent":["function mkJavaScript(parserConfig) {\n  var statementIndent = parserConfig.statementIndent;\n  var jsonldMode = parserConfig.jsonld;\n  var jsonMode = parserConfig.json || jsonldMode;\n  var isTS = parserConfig.typescript;\n  var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\n  // Tokenizer\n\n  var keywords = function () {\n    function kw(type) {\n      return {\n        type: type,\n        style: \"keyword\"\n      };\n    }\n    var A = kw(\"keyword a\"),\n      B = kw(\"keyword b\"),\n      C = kw(\"keyword c\"),\n      D = kw(\"keyword d\");\n    var operator = kw(\"operator\"),\n      atom = {\n        type: \"atom\",\n        style: \"atom\"\n      };\n    return {\n      \"if\": kw(\"if\"),\n      \"while\": A,\n      \"with\": A,\n      \"else\": B,\n      \"do\": B,\n      \"try\": B,\n      \"finally\": B,\n      \"return\": D,\n      \"break\": D,\n      \"continue\": D,\n      \"new\": kw(\"new\"),\n      \"delete\": C,\n      \"void\": C,\n      \"throw\": C,\n      \"debugger\": kw(\"debugger\"),\n      \"var\": kw(\"var\"),\n      \"const\": kw(\"var\"),\n      \"let\": kw(\"var\"),\n      \"function\": kw(\"function\"),\n      \"catch\": kw(\"catch\"),\n      \"for\": kw(\"for\"),\n      \"switch\": kw(\"switch\"),\n      \"case\": kw(\"case\"),\n      \"default\": kw(\"default\"),\n      \"in\": operator,\n      \"typeof\": operator,\n      \"instanceof\": operator,\n      \"true\": atom,\n      \"false\": atom,\n      \"null\": atom,\n      \"undefined\": atom,\n      \"NaN\": atom,\n      \"Infinity\": atom,\n      \"this\": kw(\"this\"),\n      \"class\": kw(\"class\"),\n      \"super\": kw(\"atom\"),\n      \"yield\": C,\n      \"export\": kw(\"export\"),\n      \"import\": kw(\"import\"),\n      \"extends\": C,\n      \"await\": C\n    };\n  }();\n  var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;\n  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n  function readRegexp(stream) {\n    var escaped = false,\n      next,\n      inSet = false;\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (next == \"/\" && !inSet) return;\n        if (next == \"[\") inSet = true;else if (inSet && next == \"]\") inSet = false;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp;\n    content = cont;\n    return style;\n  }\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \".\" && stream.match(/^\\d[\\d_]*(?:[eE][+\\-]?[\\d_]+)?/)) {\n      return ret(\"number\", \"number\");\n    } else if (ch == \".\" && stream.match(\"..\")) {\n      return ret(\"spread\", \"meta\");\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == \"=\" && stream.eat(\">\")) {\n      return ret(\"=>\", \"operator\");\n    } else if (ch == \"0\" && stream.match(/^(?:x[\\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^[\\d_]*(?:n|(?:\\.[\\d_]*)?(?:[eE][+\\-]?[\\d_]+)?)?/);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else if (expressionAllowed(stream, state, 1)) {\n        readRegexp(stream);\n        stream.match(/^\\b(([gimyus])(?![gimyus]*\\2))+\\b/);\n        return ret(\"regexp\", \"string.special\");\n      } else {\n        stream.eat(\"=\");\n        return ret(\"operator\", \"operator\", stream.current());\n      }\n    } else if (ch == \"`\") {\n      state.tokenize = tokenQuasi;\n      return tokenQuasi(stream, state);\n    } else if (ch == \"#\" && stream.peek() == \"!\") {\n      stream.skipToEnd();\n      return ret(\"meta\", \"meta\");\n    } else if (ch == \"#\" && stream.eatWhile(wordRE)) {\n      return ret(\"variable\", \"property\");\n    } else if (ch == \"<\" && stream.match(\"!--\") || ch == \"-\" && stream.match(\"->\") && !/\\S/.test(stream.string.slice(0, stream.start))) {\n      stream.skipToEnd();\n      return ret(\"comment\", \"comment\");\n    } else if (isOperatorChar.test(ch)) {\n      if (ch != \">\" || !state.lexical || state.lexical.type != \">\") {\n        if (stream.eat(\"=\")) {\n          if (ch == \"!\" || ch == \"=\") stream.eat(\"=\");\n        } else if (/[<>*+\\-|&?]/.test(ch)) {\n          stream.eat(ch);\n          if (ch == \">\") stream.eat(ch);\n        }\n      }\n      if (ch == \"?\" && stream.eat(\".\")) return ret(\".\");\n      return ret(\"operator\", \"operator\", stream.current());\n    } else if (wordRE.test(ch)) {\n      stream.eatWhile(wordRE);\n      var word = stream.current();\n      if (state.lastType != \".\") {\n        if (keywords.propertyIsEnumerable(word)) {\n          var kw = keywords[word];\n          return ret(kw.type, kw.style, word);\n        }\n        if (word == \"async\" && stream.match(/^(\\s|\\/\\*([^*]|\\*(?!\\/))*?\\*\\/)*[\\[\\(\\w]/, false)) return ret(\"async\", \"keyword\", word);\n      }\n      return ret(\"variable\", \"variable\", word);\n    }\n  }\n  function tokenString(quote) {\n    return function (stream, state) {\n      var escaped = false,\n        next;\n      if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)) {\n        state.tokenize = tokenBase;\n        return ret(\"jsonld-keyword\", \"meta\");\n      }\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) break;\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n  function tokenComment(stream, state) {\n    var maybeEnd = false,\n      ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = ch == \"*\";\n    }\n    return ret(\"comment\", \"comment\");\n  }\n  function tokenQuasi(stream, state) {\n    var escaped = false,\n      next;\n    while ((next = stream.next()) != null) {\n      if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    return ret(\"quasi\", \"string.special\", stream.current());\n  }\n  var brackets = \"([{}])\";\n  // This is a crude lookahead trick to try and notice that we're\n  // parsing the argument patterns for a fat-arrow function before we\n  // actually hit the arrow token. It only works if the arrow is on\n  // the same line as the arguments and there's no strange noise\n  // (comments) in between. Fallback is to only notice when we hit the\n  // arrow, and not declare the arguments as locals for the arrow\n  // body.\n  function findFatArrow(stream, state) {\n    if (state.fatArrowAt) state.fatArrowAt = null;\n    var arrow = stream.string.indexOf(\"=>\", stream.start);\n    if (arrow < 0) return;\n    if (isTS) {\n      // Try to skip TypeScript return type declarations after the arguments\n      var m = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(stream.string.slice(stream.start, arrow));\n      if (m) arrow = m.index;\n    }\n    var depth = 0,\n      sawSomething = false;\n    for (var pos = arrow - 1; pos >= 0; --pos) {\n      var ch = stream.string.charAt(pos);\n      var bracket = brackets.indexOf(ch);\n      if (bracket >= 0 && bracket < 3) {\n        if (!depth) {\n          ++pos;\n          break;\n        }\n        if (--depth == 0) {\n          if (ch == \"(\") sawSomething = true;\n          break;\n        }\n      } else if (bracket >= 3 && bracket < 6) {\n        ++depth;\n      } else if (wordRE.test(ch)) {\n        sawSomething = true;\n      } else if (/[\"'\\/`]/.test(ch)) {\n        for (;; --pos) {\n          if (pos == 0) return;\n          var next = stream.string.charAt(pos - 1);\n          if (next == ch && stream.string.charAt(pos - 2) != \"\\\\\") {\n            pos--;\n            break;\n          }\n        }\n      } else if (sawSomething && !depth) {\n        ++pos;\n        break;\n      }\n    }\n    if (sawSomething && !depth) state.fatArrowAt = pos;\n  }\n\n  // Parser\n\n  var atomicTypes = {\n    \"atom\": true,\n    \"number\": true,\n    \"variable\": true,\n    \"string\": true,\n    \"regexp\": true,\n    \"this\": true,\n    \"import\": true,\n    \"jsonld-keyword\": true\n  };\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n  function inScope(state, varname) {\n    for (var v = state.localVars; v; v = v.next) if (v.name == varname) return true;\n    for (var cx = state.context; cx; cx = cx.prev) {\n      for (var v = cx.vars; v; v = v.next) if (v.name == varname) return true;\n    }\n  }\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state;\n    cx.stream = stream;\n    cx.marked = null;\n    cx.cc = cc;\n    cx.style = style;\n    if (!state.lexical.hasOwnProperty(\"align\")) state.lexical.align = true;\n    while (true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while (cc.length && cc[cc.length - 1].lex) cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variableName.local\";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {\n    state: null,\n    column: null,\n    marked: null,\n    cc: null\n  };\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function inList(name, list) {\n    for (var v = list; v; v = v.next) if (v.name == name) return true;\n    return false;\n  }\n  function register(varname) {\n    var state = cx.state;\n    cx.marked = \"def\";\n    if (state.context) {\n      if (state.lexical.info == \"var\" && state.context && state.context.block) {\n        // FIXME function decls are also not block scoped\n        var newContext = registerVarScoped(varname, state.context);\n        if (newContext != null) {\n          state.context = newContext;\n          return;\n        }\n      } else if (!inList(varname, state.localVars)) {\n        state.localVars = new Var(varname, state.localVars);\n        return;\n      }\n    }\n    // Fall through means this is global\n    if (parserConfig.globalVars && !inList(varname, state.globalVars)) state.globalVars = new Var(varname, state.globalVars);\n  }\n  function registerVarScoped(varname, context) {\n    if (!context) {\n      return null;\n    } else if (context.block) {\n      var inner = registerVarScoped(varname, context.prev);\n      if (!inner) return null;\n      if (inner == context.prev) return context;\n      return new Context(inner, context.vars, true);\n    } else if (inList(varname, context.vars)) {\n      return context;\n    } else {\n      return new Context(context.prev, new Var(varname, context.vars), false);\n    }\n  }\n  function isModifier(name) {\n    return name == \"public\" || name == \"private\" || name == \"protected\" || name == \"abstract\" || name == \"readonly\";\n  }\n\n  // Combinators\n\n  function Context(prev, vars, block) {\n    this.prev = prev;\n    this.vars = vars;\n    this.block = block;\n  }\n  function Var(name, next) {\n    this.name = name;\n    this.next = next;\n  }\n  var defaultVars = new Var(\"this\", new Var(\"arguments\", null));\n  function pushcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, false);\n    cx.state.localVars = defaultVars;\n  }\n  function pushblockcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, true);\n    cx.state.localVars = null;\n  }\n  pushcontext.lex = pushblockcontext.lex = true;\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars;\n    cx.state.context = cx.state.context.prev;\n  }\n  popcontext.lex = true;\n  function pushlex(type, info) {\n    var result = function result() {\n      var state = cx.state,\n        indent = state.indented;\n      if (state.lexical.type == \"stat\") indent = state.lexical.indented;else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev) indent = outer.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\") state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n  function expect(wanted) {\n    function exp(type) {\n      if (type == wanted) return cont();else if (wanted == \";\" || type == \"}\" || type == \")\" || type == \"]\") return pass();else return cont(exp);\n    }\n    ;\n    return exp;\n  }\n  function statement(type, value) {\n    if (type == \"var\") return cont(pushlex(\"vardef\", value), vardef, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), parenExpr, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"keyword d\") return cx.stream.match(/^\\s*$/, false) ? cont() : cont(pushlex(\"stat\"), maybeexpression, expect(\";\"), poplex);\n    if (type == \"debugger\") return cont(expect(\";\"));\n    if (type == \"{\") return cont(pushlex(\"}\"), pushblockcontext, block, poplex, popcontext);\n    if (type == \";\") return cont();\n    if (type == \"if\") {\n      if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex) cx.state.cc.pop()();\n      return cont(pushlex(\"form\"), parenExpr, statement, poplex, maybeelse);\n    }\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), pushblockcontext, forspec, statement, popcontext, poplex);\n    if (type == \"class\" || isTS && value == \"interface\") {\n      cx.marked = \"keyword\";\n      return cont(pushlex(\"form\", type == \"class\" ? type : value), className, poplex);\n    }\n    if (type == \"variable\") {\n      if (isTS && value == \"declare\") {\n        cx.marked = \"keyword\";\n        return cont(statement);\n      } else if (isTS && (value == \"module\" || value == \"enum\" || value == \"type\") && cx.stream.match(/^\\s*\\w/, false)) {\n        cx.marked = \"keyword\";\n        if (value == \"enum\") return cont(enumdef);else if (value == \"type\") return cont(typename, expect(\"operator\"), typeexpr, expect(\";\"));else return cont(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), block, poplex, poplex);\n      } else if (isTS && value == \"namespace\") {\n        cx.marked = \"keyword\";\n        return cont(pushlex(\"form\"), expression, statement, poplex);\n      } else if (isTS && value == \"abstract\") {\n        cx.marked = \"keyword\";\n        return cont(statement);\n      } else {\n        return cont(pushlex(\"stat\"), maybelabel);\n      }\n    }\n    if (type == \"switch\") return cont(pushlex(\"form\"), parenExpr, expect(\"{\"), pushlex(\"}\", \"switch\"), pushblockcontext, block, poplex, poplex, popcontext);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);\n    if (type == \"export\") return cont(pushlex(\"stat\"), afterExport, poplex);\n    if (type == \"import\") return cont(pushlex(\"stat\"), afterImport, poplex);\n    if (type == \"async\") return cont(statement);\n    if (value == \"@\") return cont(expression, statement);\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function maybeCatchBinding(type) {\n    if (type == \"(\") return cont(funarg, expect(\")\"));\n  }\n  function expression(type, value) {\n    return expressionInner(type, value, false);\n  }\n  function expressionNoComma(type, value) {\n    return expressionInner(type, value, true);\n  }\n  function parenExpr(type) {\n    if (type != \"(\") return pass();\n    return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex);\n  }\n  function expressionInner(type, value, noComma) {\n    if (cx.state.fatArrowAt == cx.stream.start) {\n      var body = noComma ? arrowBodyNoComma : arrowBody;\n      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, expect(\"=>\"), body, popcontext);else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n    }\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == \"function\") return cont(functiondef, maybeop);\n    if (type == \"class\" || isTS && value == \"interface\") {\n      cx.marked = \"keyword\";\n      return cont(pushlex(\"form\"), classExpression, poplex);\n    }\n    if (type == \"keyword c\" || type == \"async\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeop);\n    if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n    if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n    if (type == \"quasi\") return pass(quasi, maybeop);\n    if (type == \"new\") return cont(maybeTarget(noComma));\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n  function maybeoperatorComma(type, value) {\n    if (type == \",\") return cont(maybeexpression);\n    return maybeoperatorNoComma(type, value, false);\n  }\n  function maybeoperatorNoComma(type, value, noComma) {\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n    var expr = noComma == false ? expression : expressionNoComma;\n    if (type == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n    if (type == \"operator\") {\n      if (/\\+\\+|--/.test(value) || isTS && value == \"!\") return cont(me);\n      if (isTS && value == \"<\" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\\s*\\(/, false)) return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, me);\n      if (value == \"?\") return cont(expression, expect(\":\"), expr);\n      return cont(expr);\n    }\n    if (type == \"quasi\") {\n      return pass(quasi, me);\n    }\n    if (type == \";\") return;\n    if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n    if (type == \".\") return cont(property, me);\n    if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n    if (isTS && value == \"as\") {\n      cx.marked = \"keyword\";\n      return cont(typeexpr, me);\n    }\n    if (type == \"regexp\") {\n      cx.state.lastType = cx.marked = \"operator\";\n      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1);\n      return cont(expr);\n    }\n  }\n  function quasi(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasi);\n    return cont(maybeexpression, continueQuasi);\n  }\n  function continueQuasi(type) {\n    if (type == \"}\") {\n      cx.marked = \"string.special\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasi);\n    }\n  }\n  function arrowBody(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expression);\n  }\n  function arrowBodyNoComma(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expressionNoComma);\n  }\n  function maybeTarget(noComma) {\n    return function (type) {\n      if (type == \".\") return cont(noComma ? targetNoComma : target);else if (type == \"variable\" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma);else return pass(noComma ? expressionNoComma : expression);\n    };\n  }\n  function target(_, value) {\n    if (value == \"target\") {\n      cx.marked = \"keyword\";\n      return cont(maybeoperatorComma);\n    }\n  }\n  function targetNoComma(_, value) {\n    if (value == \"target\") {\n      cx.marked = \"keyword\";\n      return cont(maybeoperatorNoComma);\n    }\n  }\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {\n      cx.marked = \"property\";\n      return cont();\n    }\n  }\n  function objprop(type, value) {\n    if (type == \"async\") {\n      cx.marked = \"property\";\n      return cont(objprop);\n    } else if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(getterSetter);\n      var m; // Work around fat-arrow-detection complication for detecting typescript typed arrow params\n      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\\s*:\\s*/, false))) cx.state.fatArrowAt = cx.stream.pos + m[0].length;\n      return cont(afterprop);\n    } else if (type == \"number\" || type == \"string\") {\n      cx.marked = jsonldMode ? \"property\" : cx.style + \" property\";\n      return cont(afterprop);\n    } else if (type == \"jsonld-keyword\") {\n      return cont(afterprop);\n    } else if (isTS && isModifier(value)) {\n      cx.marked = \"keyword\";\n      return cont(objprop);\n    } else if (type == \"[\") {\n      return cont(expression, maybetype, expect(\"]\"), afterprop);\n    } else if (type == \"spread\") {\n      return cont(expressionNoComma, afterprop);\n    } else if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(objprop);\n    } else if (type == \":\") {\n      return pass(afterprop);\n    }\n  }\n  function getterSetter(type) {\n    if (type != \"variable\") return pass(afterprop);\n    cx.marked = \"property\";\n    return cont(functiondef);\n  }\n  function afterprop(type) {\n    if (type == \":\") return cont(expressionNoComma);\n    if (type == \"(\") return pass(functiondef);\n  }\n  function commasep(what, end, sep) {\n    function proceed(type, value) {\n      if (sep ? sep.indexOf(type) > -1 : type == \",\") {\n        var lex = cx.state.lexical;\n        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n        return cont(function (type, value) {\n          if (type == end || value == end) return pass();\n          return pass(what);\n        }, proceed);\n      }\n      if (type == end || value == end) return cont();\n      if (sep && sep.indexOf(\";\") > -1) return pass(what);\n      return cont(expect(end));\n    }\n    return function (type, value) {\n      if (type == end || value == end) return cont();\n      return pass(what, proceed);\n    };\n  }\n  function contCommasep(what, end, info) {\n    for (var i = 3; i < arguments.length; i++) cx.cc.push(arguments[i]);\n    return cont(pushlex(end, info), commasep(what, end), poplex);\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type, value) {\n    if (isTS) {\n      if (type == \":\") return cont(typeexpr);\n      if (value == \"?\") return cont(maybetype);\n    }\n  }\n  function maybetypeOrIn(type, value) {\n    if (isTS && (type == \":\" || value == \"in\")) return cont(typeexpr);\n  }\n  function mayberettype(type) {\n    if (isTS && type == \":\") {\n      if (cx.stream.match(/^\\s*\\w+\\s+is\\b/, false)) return cont(expression, isKW, typeexpr);else return cont(typeexpr);\n    }\n  }\n  function isKW(_, value) {\n    if (value == \"is\") {\n      cx.marked = \"keyword\";\n      return cont();\n    }\n  }\n  function typeexpr(type, value) {\n    if (value == \"keyof\" || value == \"typeof\" || value == \"infer\" || value == \"readonly\") {\n      cx.marked = \"keyword\";\n      return cont(value == \"typeof\" ? expressionNoComma : typeexpr);\n    }\n    if (type == \"variable\" || value == \"void\") {\n      cx.marked = \"type\";\n      return cont(afterType);\n    }\n    if (value == \"|\" || value == \"&\") return cont(typeexpr);\n    if (type == \"string\" || type == \"number\" || type == \"atom\") return cont(afterType);\n    if (type == \"[\") return cont(pushlex(\"]\"), commasep(typeexpr, \"]\", \",\"), poplex, afterType);\n    if (type == \"{\") return cont(pushlex(\"}\"), typeprops, poplex, afterType);\n    if (type == \"(\") return cont(commasep(typearg, \")\"), maybeReturnType, afterType);\n    if (type == \"<\") return cont(commasep(typeexpr, \">\"), typeexpr);\n    if (type == \"quasi\") return pass(quasiType, afterType);\n  }\n  function maybeReturnType(type) {\n    if (type == \"=>\") return cont(typeexpr);\n  }\n  function typeprops(type) {\n    if (type.match(/[\\}\\)\\]]/)) return cont();\n    if (type == \",\" || type == \";\") return cont(typeprops);\n    return pass(typeprop, typeprops);\n  }\n  function typeprop(type, value) {\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      return cont(typeprop);\n    } else if (value == \"?\" || type == \"number\" || type == \"string\") {\n      return cont(typeprop);\n    } else if (type == \":\") {\n      return cont(typeexpr);\n    } else if (type == \"[\") {\n      return cont(expect(\"variable\"), maybetypeOrIn, expect(\"]\"), typeprop);\n    } else if (type == \"(\") {\n      return pass(functiondecl, typeprop);\n    } else if (!type.match(/[;\\}\\)\\],]/)) {\n      return cont();\n    }\n  }\n  function quasiType(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasiType);\n    return cont(typeexpr, continueQuasiType);\n  }\n  function continueQuasiType(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasiType);\n    }\n  }\n  function typearg(type, value) {\n    if (type == \"variable\" && cx.stream.match(/^\\s*[?:]/, false) || value == \"?\") return cont(typearg);\n    if (type == \":\") return cont(typeexpr);\n    if (type == \"spread\") return cont(typearg);\n    return pass(typeexpr);\n  }\n  function afterType(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType);\n    if (value == \"|\" || type == \".\" || value == \"&\") return cont(typeexpr);\n    if (type == \"[\") return cont(typeexpr, expect(\"]\"), afterType);\n    if (value == \"extends\" || value == \"implements\") {\n      cx.marked = \"keyword\";\n      return cont(typeexpr);\n    }\n    if (value == \"?\") return cont(typeexpr, expect(\":\"), typeexpr);\n  }\n  function maybeTypeArgs(_, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType);\n  }\n  function typeparam() {\n    return pass(typeexpr, maybeTypeDefault);\n  }\n  function maybeTypeDefault(_, value) {\n    if (value == \"=\") return cont(typeexpr);\n  }\n  function vardef(_, value) {\n    if (value == \"enum\") {\n      cx.marked = \"keyword\";\n      return cont(enumdef);\n    }\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\n  }\n  function pattern(type, value) {\n    if (isTS && isModifier(value)) {\n      cx.marked = \"keyword\";\n      return cont(pattern);\n    }\n    if (type == \"variable\") {\n      register(value);\n      return cont();\n    }\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"[\") return contCommasep(eltpattern, \"]\");\n    if (type == \"{\") return contCommasep(proppattern, \"}\");\n  }\n  function proppattern(type, value) {\n    if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n      register(value);\n      return cont(maybeAssign);\n    }\n    if (type == \"variable\") cx.marked = \"property\";\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"}\") return pass();\n    if (type == \"[\") return cont(expression, expect(']'), expect(':'), proppattern);\n    return cont(expect(\":\"), pattern, maybeAssign);\n  }\n  function eltpattern() {\n    return pass(pattern, maybeAssign);\n  }\n  function maybeAssign(_type, value) {\n    if (value == \"=\") return cont(expressionNoComma);\n  }\n  function vardefCont(type) {\n    if (type == \",\") return cont(vardef);\n  }\n  function maybeelse(type, value) {\n    if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\n  }\n  function forspec(type, value) {\n    if (value == \"await\") return cont(forspec);\n    if (type == \"(\") return cont(pushlex(\")\"), forspec1, poplex);\n  }\n  function forspec1(type) {\n    if (type == \"var\") return cont(vardef, forspec2);\n    if (type == \"variable\") return cont(forspec2);\n    return pass(forspec2);\n  }\n  function forspec2(type, value) {\n    if (type == \")\") return cont();\n    if (type == \";\") return cont(forspec2);\n    if (value == \"in\" || value == \"of\") {\n      cx.marked = \"keyword\";\n      return cont(expression, forspec2);\n    }\n    return pass(expression, forspec2);\n  }\n  function functiondef(type, value) {\n    if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(functiondef);\n    }\n    if (type == \"variable\") {\n      register(value);\n      return cont(functiondef);\n    }\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, statement, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondef);\n  }\n  function functiondecl(type, value) {\n    if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(functiondecl);\n    }\n    if (type == \"variable\") {\n      register(value);\n      return cont(functiondecl);\n    }\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondecl);\n  }\n  function typename(type, value) {\n    if (type == \"keyword\" || type == \"variable\") {\n      cx.marked = \"type\";\n      return cont(typename);\n    } else if (value == \"<\") {\n      return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex);\n    }\n  }\n  function funarg(type, value) {\n    if (value == \"@\") cont(expression, funarg);\n    if (type == \"spread\") return cont(funarg);\n    if (isTS && isModifier(value)) {\n      cx.marked = \"keyword\";\n      return cont(funarg);\n    }\n    if (isTS && type == \"this\") return cont(maybetype, maybeAssign);\n    return pass(pattern, maybetype, maybeAssign);\n  }\n  function classExpression(type, value) {\n    // Class expressions may have an optional name.\n    if (type == \"variable\") return className(type, value);\n    return classNameAfter(type, value);\n  }\n  function className(type, value) {\n    if (type == \"variable\") {\n      register(value);\n      return cont(classNameAfter);\n    }\n  }\n  function classNameAfter(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, classNameAfter);\n    if (value == \"extends\" || value == \"implements\" || isTS && type == \",\") {\n      if (value == \"implements\") cx.marked = \"keyword\";\n      return cont(isTS ? typeexpr : expression, classNameAfter);\n    }\n    if (type == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\n  }\n  function classBody(type, value) {\n    if (type == \"async\" || type == \"variable\" && (value == \"static\" || value == \"get\" || value == \"set\" || isTS && isModifier(value)) && cx.stream.match(/^\\s+#?[\\w$\\xa1-\\uffff]/, false)) {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      return cont(classfield, classBody);\n    }\n    if (type == \"number\" || type == \"string\") return cont(classfield, classBody);\n    if (type == \"[\") return cont(expression, maybetype, expect(\"]\"), classfield, classBody);\n    if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (isTS && type == \"(\") return pass(functiondecl, classBody);\n    if (type == \";\" || type == \",\") return cont(classBody);\n    if (type == \"}\") return cont();\n    if (value == \"@\") return cont(expression, classBody);\n  }\n  function classfield(type, value) {\n    if (value == \"!\" || value == \"?\") return cont(classfield);\n    if (type == \":\") return cont(typeexpr, maybeAssign);\n    if (value == \"=\") return cont(expressionNoComma);\n    var context = cx.state.lexical.prev,\n      isInterface = context && context.info == \"interface\";\n    return pass(isInterface ? functiondecl : functiondef);\n  }\n  function afterExport(type, value) {\n    if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(maybeFrom, expect(\";\"));\n    }\n    if (value == \"default\") {\n      cx.marked = \"keyword\";\n      return cont(expression, expect(\";\"));\n    }\n    if (type == \"{\") return cont(commasep(exportField, \"}\"), maybeFrom, expect(\";\"));\n    return pass(statement);\n  }\n  function exportField(type, value) {\n    if (value == \"as\") {\n      cx.marked = \"keyword\";\n      return cont(expect(\"variable\"));\n    }\n    if (type == \"variable\") return pass(expressionNoComma, exportField);\n  }\n  function afterImport(type) {\n    if (type == \"string\") return cont();\n    if (type == \"(\") return pass(expression);\n    if (type == \".\") return pass(maybeoperatorComma);\n    return pass(importSpec, maybeMoreImports, maybeFrom);\n  }\n  function importSpec(type, value) {\n    if (type == \"{\") return contCommasep(importSpec, \"}\");\n    if (type == \"variable\") register(value);\n    if (value == \"*\") cx.marked = \"keyword\";\n    return cont(maybeAs);\n  }\n  function maybeMoreImports(type) {\n    if (type == \",\") return cont(importSpec, maybeMoreImports);\n  }\n  function maybeAs(_type, value) {\n    if (value == \"as\") {\n      cx.marked = \"keyword\";\n      return cont(importSpec);\n    }\n  }\n  function maybeFrom(_type, value) {\n    if (value == \"from\") {\n      cx.marked = \"keyword\";\n      return cont(expression);\n    }\n  }\n  function arrayLiteral(type) {\n    if (type == \"]\") return cont();\n    return pass(commasep(expressionNoComma, \"]\"));\n  }\n  function enumdef() {\n    return pass(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), commasep(enummember, \"}\"), poplex, poplex);\n  }\n  function enummember() {\n    return pass(pattern, maybeAssign);\n  }\n  function isContinuedStatement(state, textAfter) {\n    return state.lastType == \"operator\" || state.lastType == \",\" || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0));\n  }\n  function expressionAllowed(stream, state, backUp) {\n    return state.tokenize == tokenBase && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)$/.test(state.lastType) || state.lastType == \"quasi\" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0)));\n  }\n\n  // Interface\n\n  return {\n    name: parserConfig.name,\n    startState: function startState(indentUnit) {\n      var state = {\n        tokenize: tokenBase,\n        lastType: \"sof\",\n        cc: [],\n        lexical: new JSLexical(-indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && new Context(null, null, false),\n        indented: 0\n      };\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\") state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n    token: function token(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\")) state.lexical.align = false;\n        state.indented = stream.indentation();\n        findFatArrow(stream, state);\n      }\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n    indent: function indent(state, textAfter, cx) {\n      if (state.tokenize == tokenComment || state.tokenize == tokenQuasi) return null;\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0),\n        lexical = state.lexical,\n        top;\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n      if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n        var c = state.cc[i];\n        if (c == poplex) lexical = lexical.prev;else if (c != maybeelse && c != popcontext) break;\n      }\n      while ((lexical.type == \"stat\" || lexical.type == \"form\") && (firstChar == \"}\" || (top = state.cc[state.cc.length - 1]) && (top == maybeoperatorComma || top == maybeoperatorNoComma) && !/^[,\\.=+\\-*:?[\\(]/.test(textAfter))) lexical = lexical.prev;\n      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\") lexical = lexical.prev;\n      var type = lexical.type,\n        closing = firstChar == type;\n      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info.length + 1 : 0);else if (type == \"form\" && firstChar == \"{\") return lexical.indented;else if (type == \"form\") return lexical.indented + cx.unit;else if (type == \"stat\") return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || cx.unit : 0);else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false) return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? cx.unit : 2 * cx.unit);else if (lexical.align) return lexical.column + (closing ? 0 : 1);else return lexical.indented + (closing ? 0 : cx.unit);\n    },\n    languageData: {\n      indentOnInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n      commentTokens: jsonMode ? undefined : {\n        line: \"//\",\n        block: {\n          open: \"/*\",\n          close: \"*/\"\n        }\n      },\n      closeBrackets: {\n        brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"`\"]\n      },\n      wordChars: \"$\"\n    }\n  };\n}\n;\nexport var javascript = mkJavaScript({\n  name: \"javascript\"\n});\nexport var json = mkJavaScript({\n  name: \"json\",\n  json: true\n});\nexport var jsonld = mkJavaScript({\n  name: \"json\",\n  jsonld: true\n});\nexport var typescript = mkJavaScript({\n  name: \"typescript\",\n  typescript: true\n});"],"sourceRoot":""}