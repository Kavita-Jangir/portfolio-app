{"version":3,"sources":["D:/react_app/app_1/node_modules/@codemirror/legacy-modes/mode/scheme.js"],"names":["__webpack_require__","r","__webpack_exports__","d","scheme","makeKeywords","str","obj","words","split","i","length","keywords","indentKeys","stateStack","indent","type","prev","this","pushStack","state","indentStack","binaryMatcher","RegExp","octalMatcher","hexMatcher","decimalMatcher","isBinaryNumber","stream","match","isOctalNumber","isDecimalNumber","backup","backUp","isHexNumber","processEscapedSequence","options","next","escaped","token","mode","name","startState","indentation","sExprComment","sExprQuote","sol","eatSpace","returnType","maybeEnd","peek","eatWhile","ch","eat","numTest","hasExactness","hasRadix","test","skipToEnd","letter","keyWord","indentTemp","column","propertyIsEnumerable","eol","current","popStack","languageData","closeBrackets","brackets","commentTokens","line"],"mappings":"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","file":"static/js/81.f036b163.chunk.js","sourcesContent":["var BUILTIN = \"builtin\",\n  COMMENT = \"comment\",\n  STRING = \"string\",\n  SYMBOL = \"symbol\",\n  ATOM = \"atom\",\n  NUMBER = \"number\",\n  BRACKET = \"bracket\";\nvar INDENT_WORD_SKIP = 2;\nfunction makeKeywords(str) {\n  var obj = {},\n    words = str.split(\" \");\n  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n  return obj;\n}\nvar keywords = makeKeywords(\"Î» case-lambda call/cc class cond-expand define-class define-values exit-handler field import inherit init-field interface let*-values let-values let/ec mixin opt-lambda override protect provide public rename require require-for-syntax syntax syntax-case syntax-error unit/sig unless when with-syntax and begin call-with-current-continuation call-with-input-file call-with-output-file case cond define define-syntax define-macro defmacro delay do dynamic-wind else for-each if lambda let let* let-syntax letrec letrec-syntax map or syntax-rules abs acos angle append apply asin assoc assq assv atan boolean? caar cadr call-with-input-file call-with-output-file call-with-values car cdddar cddddr cdr ceiling char->integer char-alphabetic? char-ci<=? char-ci<? char-ci=? char-ci>=? char-ci>? char-downcase char-lower-case? char-numeric? char-ready? char-upcase char-upper-case? char-whitespace? char<=? char<? char=? char>=? char>? char? close-input-port close-output-port complex? cons cos current-input-port current-output-port denominator display eof-object? eq? equal? eqv? eval even? exact->inexact exact? exp expt #f floor force gcd imag-part inexact->exact inexact? input-port? integer->char integer? interaction-environment lcm length list list->string list->vector list-ref list-tail list? load log magnitude make-polar make-rectangular make-string make-vector max member memq memv min modulo negative? newline not null-environment null? number->string number? numerator odd? open-input-file open-output-file output-port? pair? peek-char port? positive? procedure? quasiquote quote quotient rational? rationalize read read-char real-part real? remainder reverse round scheme-report-environment set! set-car! set-cdr! sin sqrt string string->list string->number string->symbol string-append string-ci<=? string-ci<? string-ci=? string-ci>=? string-ci>? string-copy string-fill! string-length string-ref string-set! string<=? string<? string=? string>=? string>? string? substring symbol->string symbol? #t tan transcript-off transcript-on truncate values vector vector->list vector-fill! vector-length vector-ref vector-set! with-input-from-file with-output-to-file write write-char zero?\");\nvar indentKeys = makeKeywords(\"define let letrec let* lambda define-macro defmacro let-syntax letrec-syntax let-values let*-values define-syntax syntax-rules define-values when unless\");\nfunction stateStack(indent, type, prev) {\n  // represents a state stack object\n  this.indent = indent;\n  this.type = type;\n  this.prev = prev;\n}\nfunction pushStack(state, indent, type) {\n  state.indentStack = new stateStack(indent, type, state.indentStack);\n}\nfunction popStack(state) {\n  state.indentStack = state.indentStack.prev;\n}\nvar binaryMatcher = new RegExp(/^(?:[-+]i|[-+][01]+#*(?:\\/[01]+#*)?i|[-+]?[01]+#*(?:\\/[01]+#*)?@[-+]?[01]+#*(?:\\/[01]+#*)?|[-+]?[01]+#*(?:\\/[01]+#*)?[-+](?:[01]+#*(?:\\/[01]+#*)?)?i|[-+]?[01]+#*(?:\\/[01]+#*)?)(?=[()\\s;\"]|$)/i);\nvar octalMatcher = new RegExp(/^(?:[-+]i|[-+][0-7]+#*(?:\\/[0-7]+#*)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?@[-+]?[0-7]+#*(?:\\/[0-7]+#*)?|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?[-+](?:[0-7]+#*(?:\\/[0-7]+#*)?)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?)(?=[()\\s;\"]|$)/i);\nvar hexMatcher = new RegExp(/^(?:[-+]i|[-+][\\da-f]+#*(?:\\/[\\da-f]+#*)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?@[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?[-+](?:[\\da-f]+#*(?:\\/[\\da-f]+#*)?)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?)(?=[()\\s;\"]|$)/i);\nvar decimalMatcher = new RegExp(/^(?:[-+]i|[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)i|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)@[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)?i|(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*))(?=[()\\s;\"]|$)/i);\nfunction isBinaryNumber(stream) {\n  return stream.match(binaryMatcher);\n}\nfunction isOctalNumber(stream) {\n  return stream.match(octalMatcher);\n}\nfunction isDecimalNumber(stream, backup) {\n  if (backup === true) {\n    stream.backUp(1);\n  }\n  return stream.match(decimalMatcher);\n}\nfunction isHexNumber(stream) {\n  return stream.match(hexMatcher);\n}\nfunction processEscapedSequence(stream, options) {\n  var next,\n    escaped = false;\n  while ((next = stream.next()) != null) {\n    if (next == options.token && !escaped) {\n      options.state.mode = false;\n      break;\n    }\n    escaped = !escaped && next == \"\\\\\";\n  }\n}\nexport var scheme = {\n  name: \"scheme\",\n  startState: function startState() {\n    return {\n      indentStack: null,\n      indentation: 0,\n      mode: false,\n      sExprComment: false,\n      sExprQuote: false\n    };\n  },\n  token: function token(stream, state) {\n    if (state.indentStack == null && stream.sol()) {\n      // update indentation, but only if indentStack is empty\n      state.indentation = stream.indentation();\n    }\n\n    // skip spaces\n    if (stream.eatSpace()) {\n      return null;\n    }\n    var returnType = null;\n    switch (state.mode) {\n      case \"string\":\n        // multi-line string parsing mode\n        processEscapedSequence(stream, {\n          token: \"\\\"\",\n          state: state\n        });\n        returnType = STRING; // continue on in scheme-string mode\n        break;\n      case \"symbol\":\n        // escape symbol\n        processEscapedSequence(stream, {\n          token: \"|\",\n          state: state\n        });\n        returnType = SYMBOL; // continue on in scheme-symbol mode\n        break;\n      case \"comment\":\n        // comment parsing mode\n        var next,\n          maybeEnd = false;\n        while ((next = stream.next()) != null) {\n          if (next == \"#\" && maybeEnd) {\n            state.mode = false;\n            break;\n          }\n          maybeEnd = next == \"|\";\n        }\n        returnType = COMMENT;\n        break;\n      case \"s-expr-comment\":\n        // s-expr commenting mode\n        state.mode = false;\n        if (stream.peek() == \"(\" || stream.peek() == \"[\") {\n          // actually start scheme s-expr commenting mode\n          state.sExprComment = 0;\n        } else {\n          // if not we just comment the entire of the next token\n          stream.eatWhile(/[^\\s\\(\\)\\[\\]]/); // eat symbol atom\n          returnType = COMMENT;\n          break;\n        }\n      default:\n        // default parsing mode\n        var ch = stream.next();\n        if (ch == \"\\\"\") {\n          state.mode = \"string\";\n          returnType = STRING;\n        } else if (ch == \"'\") {\n          if (stream.peek() == \"(\" || stream.peek() == \"[\") {\n            if (typeof state.sExprQuote != \"number\") {\n              state.sExprQuote = 0;\n            } // else already in a quoted expression\n            returnType = ATOM;\n          } else {\n            stream.eatWhile(/[\\w_\\-!$%&*+\\.\\/:<=>?@\\^~]/);\n            returnType = ATOM;\n          }\n        } else if (ch == '|') {\n          state.mode = \"symbol\";\n          returnType = SYMBOL;\n        } else if (ch == '#') {\n          if (stream.eat(\"|\")) {\n            // Multi-line comment\n            state.mode = \"comment\"; // toggle to comment mode\n            returnType = COMMENT;\n          } else if (stream.eat(/[tf]/i)) {\n            // #t/#f (atom)\n            returnType = ATOM;\n          } else if (stream.eat(';')) {\n            // S-Expr comment\n            state.mode = \"s-expr-comment\";\n            returnType = COMMENT;\n          } else {\n            var numTest = null,\n              hasExactness = false,\n              hasRadix = true;\n            if (stream.eat(/[ei]/i)) {\n              hasExactness = true;\n            } else {\n              stream.backUp(1); // must be radix specifier\n            }\n\n            if (stream.match(/^#b/i)) {\n              numTest = isBinaryNumber;\n            } else if (stream.match(/^#o/i)) {\n              numTest = isOctalNumber;\n            } else if (stream.match(/^#x/i)) {\n              numTest = isHexNumber;\n            } else if (stream.match(/^#d/i)) {\n              numTest = isDecimalNumber;\n            } else if (stream.match(/^[-+0-9.]/, false)) {\n              hasRadix = false;\n              numTest = isDecimalNumber;\n              // re-consume the initial # if all matches failed\n            } else if (!hasExactness) {\n              stream.eat('#');\n            }\n            if (numTest != null) {\n              if (hasRadix && !hasExactness) {\n                // consume optional exactness after radix\n                stream.match(/^#[ei]/i);\n              }\n              if (numTest(stream)) returnType = NUMBER;\n            }\n          }\n        } else if (/^[-+0-9.]/.test(ch) && isDecimalNumber(stream, true)) {\n          // match non-prefixed number, must be decimal\n          returnType = NUMBER;\n        } else if (ch == \";\") {\n          // comment\n          stream.skipToEnd(); // rest of the line is a comment\n          returnType = COMMENT;\n        } else if (ch == \"(\" || ch == \"[\") {\n          var keyWord = '';\n          var indentTemp = stream.column(),\n            letter;\n          /**\n             Either\n             (indent-word ..\n             (non-indent-word ..\n             (;something else, bracket, etc.\n          */\n\n          while ((letter = stream.eat(/[^\\s\\(\\[\\;\\)\\]]/)) != null) {\n            keyWord += letter;\n          }\n          if (keyWord.length > 0 && indentKeys.propertyIsEnumerable(keyWord)) {\n            // indent-word\n\n            pushStack(state, indentTemp + INDENT_WORD_SKIP, ch);\n          } else {\n            // non-indent word\n            // we continue eating the spaces\n            stream.eatSpace();\n            if (stream.eol() || stream.peek() == \";\") {\n              // nothing significant after\n              // we restart indentation 1 space after\n              pushStack(state, indentTemp + 1, ch);\n            } else {\n              pushStack(state, indentTemp + stream.current().length, ch); // else we match\n            }\n          }\n\n          stream.backUp(stream.current().length - 1); // undo all the eating\n\n          if (typeof state.sExprComment == \"number\") state.sExprComment++;\n          if (typeof state.sExprQuote == \"number\") state.sExprQuote++;\n          returnType = BRACKET;\n        } else if (ch == \")\" || ch == \"]\") {\n          returnType = BRACKET;\n          if (state.indentStack != null && state.indentStack.type == (ch == \")\" ? \"(\" : \"[\")) {\n            popStack(state);\n            if (typeof state.sExprComment == \"number\") {\n              if (--state.sExprComment == 0) {\n                returnType = COMMENT; // final closing bracket\n                state.sExprComment = false; // turn off s-expr commenting mode\n              }\n            }\n\n            if (typeof state.sExprQuote == \"number\") {\n              if (--state.sExprQuote == 0) {\n                returnType = ATOM; // final closing bracket\n                state.sExprQuote = false; // turn off s-expr quote mode\n              }\n            }\n          }\n        } else {\n          stream.eatWhile(/[\\w_\\-!$%&*+\\.\\/:<=>?@\\^~]/);\n          if (keywords && keywords.propertyIsEnumerable(stream.current())) {\n            returnType = BUILTIN;\n          } else returnType = \"variable\";\n        }\n    }\n    return typeof state.sExprComment == \"number\" ? COMMENT : typeof state.sExprQuote == \"number\" ? ATOM : returnType;\n  },\n  indent: function indent(state) {\n    if (state.indentStack == null) return state.indentation;\n    return state.indentStack.indent;\n  },\n  languageData: {\n    closeBrackets: {\n      brackets: [\"(\", \"[\", \"{\", '\"']\n    },\n    commentTokens: {\n      line: \";;\"\n    }\n  }\n};"],"sourceRoot":""}