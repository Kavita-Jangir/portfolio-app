{"version":3,"sources":["D:/react_app/app_1/node_modules/@codemirror/legacy-modes/mode/livescript.js"],"names":["__webpack_require__","r","__webpack_exports__","d","liveScript","tokenBase","stream","state","next_rule","next","nr","Rules","splice","i$","length","regex","match","token","identifier","indenter","RegExp","keywordend","stringfill","start","heregex","key","comment","qdoc","qqdoc","qstring","qqstring","js","words","idx","i","len","rr","name","startState","lastToken","style","indent","content","pos","indentation","current","replace"],"mappings":"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","file":"static/js/57.6ca8ce90.chunk.js","sourcesContent":["var tokenBase = function tokenBase(stream, state) {\n  var next_rule = state.next || \"start\";\n  if (next_rule) {\n    state.next = state.next;\n    var nr = Rules[next_rule];\n    if (nr.splice) {\n      for (var i$ = 0; i$ < nr.length; ++i$) {\n        var r = nr[i$];\n        if (r.regex && stream.match(r.regex)) {\n          state.next = r.next || state.next;\n          return r.token;\n        }\n      }\n      stream.next();\n      return 'error';\n    }\n    if (stream.match(r = Rules[next_rule])) {\n      if (r.regex && stream.match(r.regex)) {\n        state.next = r.next;\n        return r.token;\n      } else {\n        stream.next();\n        return 'error';\n      }\n    }\n  }\n  stream.next();\n  return 'error';\n};\nvar identifier = \"(?![\\\\d\\\\s])[$\\\\w\\\\xAA-\\\\uFFDC](?:(?!\\\\s)[$\\\\w\\\\xAA-\\\\uFFDC]|-[A-Za-z])*\";\nvar indenter = RegExp('(?:[({[=:]|[-~]>|\\\\b(?:e(?:lse|xport)|d(?:o|efault)|t(?:ry|hen)|finally|import(?:\\\\s*all)?|const|var|let|new|catch(?:\\\\s*' + identifier + ')?))\\\\s*$');\nvar keywordend = '(?![$\\\\w]|-[A-Za-z]|\\\\s*:(?![:=]))';\nvar stringfill = {\n  token: 'string',\n  regex: '.+'\n};\nvar Rules = {\n  start: [{\n    token: 'docComment',\n    regex: '/\\\\*',\n    next: 'comment'\n  }, {\n    token: 'comment',\n    regex: '#.*'\n  }, {\n    token: 'keyword',\n    regex: '(?:t(?:h(?:is|row|en)|ry|ypeof!?)|c(?:on(?:tinue|st)|a(?:se|tch)|lass)|i(?:n(?:stanceof)?|mp(?:ort(?:\\\\s+all)?|lements)|[fs])|d(?:e(?:fault|lete|bugger)|o)|f(?:or(?:\\\\s+own)?|inally|unction)|s(?:uper|witch)|e(?:lse|x(?:tends|port)|val)|a(?:nd|rguments)|n(?:ew|ot)|un(?:less|til)|w(?:hile|ith)|o[fr]|return|break|let|var|loop)' + keywordend\n  }, {\n    token: 'atom',\n    regex: '(?:true|false|yes|no|on|off|null|void|undefined)' + keywordend\n  }, {\n    token: 'invalid',\n    regex: '(?:p(?:ackage|r(?:ivate|otected)|ublic)|i(?:mplements|nterface)|enum|static|yield)' + keywordend\n  }, {\n    token: 'className.standard',\n    regex: '(?:R(?:e(?:gExp|ferenceError)|angeError)|S(?:tring|yntaxError)|E(?:rror|valError)|Array|Boolean|Date|Function|Number|Object|TypeError|URIError)' + keywordend\n  }, {\n    token: 'variableName.function.standard',\n    regex: '(?:is(?:NaN|Finite)|parse(?:Int|Float)|Math|JSON|(?:en|de)codeURI(?:Component)?)' + keywordend\n  }, {\n    token: 'variableName.standard',\n    regex: '(?:t(?:hat|il|o)|f(?:rom|allthrough)|it|by|e)' + keywordend\n  }, {\n    token: 'variableName',\n    regex: identifier + '\\\\s*:(?![:=])'\n  }, {\n    token: 'variableName',\n    regex: identifier\n  }, {\n    token: 'operatorKeyword',\n    regex: '(?:\\\\.{3}|\\\\s+\\\\?)'\n  }, {\n    token: 'keyword',\n    regex: '(?:@+|::|\\\\.\\\\.)',\n    next: 'key'\n  }, {\n    token: 'operatorKeyword',\n    regex: '\\\\.\\\\s*',\n    next: 'key'\n  }, {\n    token: 'string',\n    regex: '\\\\\\\\\\\\S[^\\\\s,;)}\\\\]]*'\n  }, {\n    token: 'docString',\n    regex: '\\'\\'\\'',\n    next: 'qdoc'\n  }, {\n    token: 'docString',\n    regex: '\"\"\"',\n    next: 'qqdoc'\n  }, {\n    token: 'string',\n    regex: '\\'',\n    next: 'qstring'\n  }, {\n    token: 'string',\n    regex: '\"',\n    next: 'qqstring'\n  }, {\n    token: 'string',\n    regex: '`',\n    next: 'js'\n  }, {\n    token: 'string',\n    regex: '<\\\\[',\n    next: 'words'\n  }, {\n    token: 'regexp',\n    regex: '//',\n    next: 'heregex'\n  }, {\n    token: 'regexp',\n    regex: '\\\\/(?:[^[\\\\/\\\\n\\\\\\\\]*(?:(?:\\\\\\\\.|\\\\[[^\\\\]\\\\n\\\\\\\\]*(?:\\\\\\\\.[^\\\\]\\\\n\\\\\\\\]*)*\\\\])[^[\\\\/\\\\n\\\\\\\\]*)*)\\\\/[gimy$]{0,4}',\n    next: 'key'\n  }, {\n    token: 'number',\n    regex: '(?:0x[\\\\da-fA-F][\\\\da-fA-F_]*|(?:[2-9]|[12]\\\\d|3[0-6])r[\\\\da-zA-Z][\\\\da-zA-Z_]*|(?:\\\\d[\\\\d_]*(?:\\\\.\\\\d[\\\\d_]*)?|\\\\.\\\\d[\\\\d_]*)(?:e[+-]?\\\\d[\\\\d_]*)?[\\\\w$]*)'\n  }, {\n    token: 'paren',\n    regex: '[({[]'\n  }, {\n    token: 'paren',\n    regex: '[)}\\\\]]',\n    next: 'key'\n  }, {\n    token: 'operatorKeyword',\n    regex: '\\\\S+'\n  }, {\n    token: 'content',\n    regex: '\\\\s+'\n  }],\n  heregex: [{\n    token: 'regexp',\n    regex: '.*?//[gimy$?]{0,4}',\n    next: 'start'\n  }, {\n    token: 'regexp',\n    regex: '\\\\s*#{'\n  }, {\n    token: 'comment',\n    regex: '\\\\s+(?:#.*)?'\n  }, {\n    token: 'regexp',\n    regex: '\\\\S+'\n  }],\n  key: [{\n    token: 'operatorKeyword',\n    regex: '[.?@!]+'\n  }, {\n    token: 'variableName',\n    regex: identifier,\n    next: 'start'\n  }, {\n    token: 'content',\n    regex: '',\n    next: 'start'\n  }],\n  comment: [{\n    token: 'docComment',\n    regex: '.*?\\\\*/',\n    next: 'start'\n  }, {\n    token: 'docComment',\n    regex: '.+'\n  }],\n  qdoc: [{\n    token: 'string',\n    regex: \".*?'''\",\n    next: 'key'\n  }, stringfill],\n  qqdoc: [{\n    token: 'string',\n    regex: '.*?\"\"\"',\n    next: 'key'\n  }, stringfill],\n  qstring: [{\n    token: 'string',\n    regex: '[^\\\\\\\\\\']*(?:\\\\\\\\.[^\\\\\\\\\\']*)*\\'',\n    next: 'key'\n  }, stringfill],\n  qqstring: [{\n    token: 'string',\n    regex: '[^\\\\\\\\\"]*(?:\\\\\\\\.[^\\\\\\\\\"]*)*\"',\n    next: 'key'\n  }, stringfill],\n  js: [{\n    token: 'string',\n    regex: '[^\\\\\\\\`]*(?:\\\\\\\\.[^\\\\\\\\`]*)*`',\n    next: 'key'\n  }, stringfill],\n  words: [{\n    token: 'string',\n    regex: '.*?\\\\]>',\n    next: 'key'\n  }, stringfill]\n};\nfor (var idx in Rules) {\n  var r = Rules[idx];\n  if (r.splice) {\n    for (var i = 0, len = r.length; i < len; ++i) {\n      var rr = r[i];\n      if (typeof rr.regex === 'string') {\n        Rules[idx][i].regex = new RegExp('^' + rr.regex);\n      }\n    }\n  } else if (typeof rr.regex === 'string') {\n    Rules[idx].regex = new RegExp('^' + r.regex);\n  }\n}\nexport var liveScript = {\n  name: \"livescript\",\n  startState: function startState() {\n    return {\n      next: 'start',\n      lastToken: {\n        style: null,\n        indent: 0,\n        content: \"\"\n      }\n    };\n  },\n  token: function token(stream, state) {\n    while (stream.pos == stream.start) var style = tokenBase(stream, state);\n    state.lastToken = {\n      style: style,\n      indent: stream.indentation(),\n      content: stream.current()\n    };\n    return style.replace(/\\./g, ' ');\n  },\n  indent: function indent(state) {\n    var indentation = state.lastToken.indent;\n    if (state.lastToken.content.match(indenter)) {\n      indentation += 2;\n    }\n    return indentation;\n  }\n};"],"sourceRoot":""}