{"version":3,"sources":["D:/react_app/app_1/node_modules/@codemirror/legacy-modes/mode/mbox.js"],"names":["__webpack_require__","r","__webpack_exports__","d","mbox","rfc2822","rfc2822NoEmail","whitespace","separator","rfc2822Header","RegExp","join","rfc2822HeaderNoEmail","header","email","untilEmail","bracketedEmail","untilBracketedEmail","name","startState","inSeparator","inHeader","emailPermitted","inHeaders","token","stream","state","sol","match","skipToEnd","style","styleForHeader","blankLine","languageData","autocomplete","concat"],"mappings":"2FAAAA,EAAAC,EAAAC,GAAAF,EAAAG,EAAAD,EAAA,yBAAAE,IAAA,IAAAC,EAAA,qMACAC,EAAA,uDACAC,EAAA,SACAC,EAAA,SACAC,EAAA,IAAAC,OAAA,KAAAL,EAAAM,KAAA,YACAC,EAAA,IAAAF,OAAA,KAAAJ,EAAAK,KAAA,YACAE,EAAA,UACAC,EAAA,eACAC,EAAA,uBACAC,EAAA,SACAC,EAAA,eA8DO,IAAAb,EAAA,CACPc,KAAA,OACAC,WAAA,WACA,OAEAC,aAAA,EAEAC,UAAA,EAEAC,gBAAA,EAEAT,OAAA,KAEAU,WAAA,IAGAC,MAzEA,SAAAC,EAAAC,GACA,GAAAD,EAAAE,MAAA,CAGA,GADAD,EAAAN,aAAA,EACAM,EAAAL,UAAAI,EAAAG,MAAArB,GAEA,YAKA,GAHAmB,EAAAL,UAAA,EACAK,EAAAb,OAAA,KAEAY,EAAAG,MAAApB,GAGA,OAFAkB,EAAAH,WAAA,EACAG,EAAAN,aAAA,EACA,OAEA,IAAAQ,EACAN,GAAA,EACA,OAAAM,EAAAH,EAAAG,MAAAhB,MAAAU,GAAA,KAAAM,EAAAH,EAAAG,MAAAnB,KACAiB,EAAAH,WAAA,EACAG,EAAAL,UAAA,EACAK,EAAAJ,iBACAI,EAAAb,OAAAe,EAAA,GACA,QAKAF,EAAAH,YAAAK,EAAAH,EAAAG,MAAAf,KACAa,EAAAL,UAAA,EACAK,EAAAJ,gBAAA,EACAI,EAAAb,OAAAe,EAAA,GACA,SAEAF,EAAAH,WAAA,EACAE,EAAAI,YACA,MAEA,GAAAH,EAAAN,YACA,OAAAK,EAAAG,MAAAd,GAAA,OACAW,EAAAG,MAAAb,GAAA,QACAU,EAAAI,YACA,QAEA,GAAAH,EAAAL,SAAA,CACA,IAAAS,EAjDA,SAAAjB,GACA,kBAAAA,EAAA,SACA,SA+CAkB,CAAAL,EAAAb,QACA,GAAAa,EAAAJ,eAAA,CACA,GAAAG,EAAAG,MAAAZ,GAAA,OAAAc,EAAA,QACA,GAAAL,EAAAG,MAAAX,GAAA,OAAAa,EAGA,OADAL,EAAAI,YACAC,EAGA,OADAL,EAAAI,YACA,MAoBAG,UAAA,SAAAN,GACAA,EAAAH,UAAAG,EAAAN,YAAAM,EAAAL,UAAA,GAEAY,aAAA,CACAC,aAAA7B,EAAA8B,OAAA7B","file":"static/js/60.4a6ec7f9.chunk.js","sourcesContent":["var rfc2822 = [\"From\", \"Sender\", \"Reply-To\", \"To\", \"Cc\", \"Bcc\", \"Message-ID\", \"In-Reply-To\", \"References\", \"Resent-From\", \"Resent-Sender\", \"Resent-To\", \"Resent-Cc\", \"Resent-Bcc\", \"Resent-Message-ID\", \"Return-Path\", \"Received\"];\nvar rfc2822NoEmail = [\"Date\", \"Subject\", \"Comments\", \"Keywords\", \"Resent-Date\"];\nvar whitespace = /^[ \\t]/;\nvar separator = /^From /; // See RFC 4155\nvar rfc2822Header = new RegExp(\"^(\" + rfc2822.join(\"|\") + \"): \");\nvar rfc2822HeaderNoEmail = new RegExp(\"^(\" + rfc2822NoEmail.join(\"|\") + \"): \");\nvar header = /^[^:]+:/; // Optional fields defined in RFC 2822\nvar email = /^[^ ]+@[^ ]+/;\nvar untilEmail = /^.*?(?=[^ ]+?@[^ ]+)/;\nvar bracketedEmail = /^<.*?>/;\nvar untilBracketedEmail = /^.*?(?=<.*>)/;\nfunction styleForHeader(header) {\n  if (header === \"Subject\") return \"header\";\n  return \"string\";\n}\nfunction readToken(stream, state) {\n  if (stream.sol()) {\n    // From last line\n    state.inSeparator = false;\n    if (state.inHeader && stream.match(whitespace)) {\n      // Header folding\n      return null;\n    } else {\n      state.inHeader = false;\n      state.header = null;\n    }\n    if (stream.match(separator)) {\n      state.inHeaders = true;\n      state.inSeparator = true;\n      return \"atom\";\n    }\n    var match;\n    var emailPermitted = false;\n    if ((match = stream.match(rfc2822HeaderNoEmail)) || (emailPermitted = true) && (match = stream.match(rfc2822Header))) {\n      state.inHeaders = true;\n      state.inHeader = true;\n      state.emailPermitted = emailPermitted;\n      state.header = match[1];\n      return \"atom\";\n    }\n\n    // Use vim's heuristics: recognize custom headers only if the line is in a\n    // block of legitimate headers.\n    if (state.inHeaders && (match = stream.match(header))) {\n      state.inHeader = true;\n      state.emailPermitted = true;\n      state.header = match[1];\n      return \"atom\";\n    }\n    state.inHeaders = false;\n    stream.skipToEnd();\n    return null;\n  }\n  if (state.inSeparator) {\n    if (stream.match(email)) return \"link\";\n    if (stream.match(untilEmail)) return \"atom\";\n    stream.skipToEnd();\n    return \"atom\";\n  }\n  if (state.inHeader) {\n    var style = styleForHeader(state.header);\n    if (state.emailPermitted) {\n      if (stream.match(bracketedEmail)) return style + \" link\";\n      if (stream.match(untilBracketedEmail)) return style;\n    }\n    stream.skipToEnd();\n    return style;\n  }\n  stream.skipToEnd();\n  return null;\n}\n;\nexport var mbox = {\n  name: \"mbox\",\n  startState: function startState() {\n    return {\n      // Is in a mbox separator\n      inSeparator: false,\n      // Is in a mail header\n      inHeader: false,\n      // If bracketed email is permitted. Only applicable when inHeader\n      emailPermitted: false,\n      // Name of current header\n      header: null,\n      // Is in a region of mail headers\n      inHeaders: false\n    };\n  },\n  token: readToken,\n  blankLine: function blankLine(state) {\n    state.inHeaders = state.inSeparator = state.inHeader = false;\n  },\n  languageData: {\n    autocomplete: rfc2822.concat(rfc2822NoEmail)\n  }\n};"],"sourceRoot":""}